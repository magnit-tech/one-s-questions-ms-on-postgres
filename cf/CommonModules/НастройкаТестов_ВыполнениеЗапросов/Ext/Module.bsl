#Область ПрограммныйИнтерфейс

Процедура ВыполнениеЗапросовФон(Параметры, АдресХранилища) Экспорт 

	Результат = ВыполнениеЗапросов(Параметры.НастройкаТеста, Параметры.ОчиститьЭтап, Параметры.ПараметрыТеста);
	ПоместитьВоВременноеХранилище(Результат, АдресХранилища);

КонецПроцедуры

Функция ВыполнениеЗапросов(НастройкаТеста, ОчиститьЭтап = Ложь, ПараметрыТеста = Неопределено) Экспорт 
	
	ДатаНачалаОбщая = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Результат = НастройкаТестовСервер.РезультатВыполненияФоновогоЗаданияЭтапа();
	Если ПараметрыТеста = Неопределено Тогда
		ПараметрыТеста = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(НастройкаТеста, "СтрокаПодключенияКPostgres,ИнтервалОбработкиДанных,КоэффициентОжиданияВыполненияЗапросовНаPostgres,МинимальнаяДлительностьВыполненияЗапроса");
	КонецЕсли;
	
	Попытка
		
		ВременныеТаблицыPostgres = НастройкаТестов_СозданиеВременныхТаблиц.ВременныеТаблицыPostgres(НастройкаТеста,,,,,1);
		Если Не ЗначениеЗаполнено(ВременныеТаблицыPostgres) Тогда
			ТекстОшибки = "Нет данных по временным таблицам Postgres!";
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
			Результат.ОписаниеОшибки = ТекстОшибки;
			Возврат Результат;
		КонецЕсли;
		
		Если Не ОчиститьЭтап Тогда
			ЭтапОбработки = НастройкаТестовСервер.ЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.ВыполнениеЗапросов);
			ОчиститьЭтап = ЭтапОбработки.НомерИтерации = 0;
		КонецЕсли;
		
		Если ОчиститьЭтап Тогда                                                                                                  
			НастройкаТестовСервер.ОчиститьЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.ВыполнениеЗапросов);
		КонецЕсли;
		
		Многопоточность = НастройкаТестовСервер.Многопоточность();
		
		// Подготовим вспомогательные таблицы
		ДопТаблицы = Новый Структура;
		ДопТаблицы.Вставить("Многопоточность", 			Многопоточность);
		ДопТаблицы.Вставить("ОчиститьЭтап", 			ОчиститьЭтап);
		ДопТаблицы.Вставить("ПараметрыТеста", 			ПараметрыТеста);
		ДопТаблицы.Вставить("Соединения", 				Новый Соответствие);
		ДопТаблицы.Вставить("НастройкаТеста", 			НастройкаТеста);
		
		// Если рассчет не многопотоковый, то можно получить сразу все вспомогательные таблицы, которые зависят от сессий и наполняются при рассчетах
		Если Не Многопоточность Тогда
			ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы);
		КонецЕсли;
		
		ИсключитьВидОшибок = Новый Массив;
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ОшибкаMSSQL);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ПропущенныйЗапросMsSQL);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ПропущенныйЗапросPostgres);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ОшибкаПреобразования);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ПропускатьПриВыполнении);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ПропускатьПриПреобразовании);
		
		// Отдельная структура под отборы для получения данных из РС Результаты...
		Отборы = НастройкаТестовСервер.ОтборыТаблицыРезультатов();
		Отборы.ПараметрыТеста 		= ПараметрыТеста;
		Отборы.ИсключитьВидОшибок 	= ИсключитьВидОшибок;
		ДопТаблицы.Вставить("Отборы", Отборы);
		
		НастройкаТестовСервер.РасчетИтераций(НастройкаТеста, ДопТаблицы);
		ДопТаблицы.Вставить("ДатаМаксимум", ДопТаблицы.НастройкиИтераций.ДатаМаксимум);
		
		Пока Истина Цикл
			
			ДатаНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
			ДопТаблицы.Вставить("ДатаНачала", ДатаНачала);
			ЭтапОбработки = НастройкаТестовСервер.ЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.ВыполнениеЗапросов, ДопТаблицы.НастройкиИтераций);
			ДопТаблицы.Вставить("ЭтапОбработки", ЭтапОбработки);
			
			Если ПараметрыТеста.ИнтервалОбработкиДанных = 0 Тогда 
				ЗаголовокСообщения = "Выполнение запросов";
				ТекстСообщения = "Из всех записей...";
			Иначе
				ЗаголовокСообщения = СтрШаблон("Выполнение запросов. Итерация %1 из %2", ЭтапОбработки.НомерИтерации, ДопТаблицы.НастройкиИтераций.Итераций);
				ТекстСообщения = СтрШаблон("Обработка записей за %1 мин. с %2", ПараметрыТеста.ИнтервалОбработкиДанных, Формат(ЭтапОбработки.ТекущаяДатаСобытия, "ДЛФ=DT"));
			КонецЕсли;
			
			ДопТаблицы.Вставить("ЗаголовокСообщения", 	ЗаголовокСообщения);
			ДопТаблицы.Вставить("ТекстСообщения", 		ТекстСообщения);
			ДопТаблицы.Вставить("Метод", 				"НастройкаТестов_ВыполнениеЗапросов.ВыполнитьОдинПоток");
			ДопТаблицы.Вставить("ПредставлениеЭтапа", 	"Выполнение запросов");
			ДопТаблицы.Вставить("ПодразделЖР", 			"ВыпонениеЗапросов"); 
			
			// Подготовка к многопоточности
			Если Многопоточность Тогда
				МассивЗаданий = НастройкаТестовСервер.СоздатьЗапуститьПотоки(НастройкаТеста, Результат, ДопТаблицы);
				Если Результат.ОшибкаВыполнения Тогда
					Прервать;	
				КонецЕсли;
				ДопТаблицы.Вставить("МассивЗаданий", МассивЗаданий);
			КонецЕсли;
			
			НастройкаТестовСервер.ВыполнитьИтерациюЭтапа(НастройкаТеста, ДопТаблицы, Результат);
			
			Если Результат.ОшибкаВыполнения Или ДопТаблицы.ЭтапОбработки.Завершен Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЦикла;	
		
		Если Не Результат.ОшибкаВыполнения Тогда
			НастройкаТестовСервер.СообщитьДлительностьОперации(НастройкаТеста,ДопТаблицы.ПредставлениеЭтапа, ДатаНачалаОбщая);
			Результат.Вставить("ЭтапЗавершен", Истина);
		КонецЕсли;
		
	Исключение
		
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		НастройкаТестовСервер.СообщитьОшибку(НастройкаТеста, "ВыполнениеЗапросов", ИнформацияОбОшибке, Результат);
		
	КонецПопытки;
	
	ЗакрытьСоединение(НастройкаТеста,ДопТаблицы.Соединения, Результат); 
	
	Возврат Результат;

КонецФункции

Процедура ВыполнениеЗапросовПоСтрокамФон(Параметры, АдресХранилища) Экспорт 

	Результат = ВыполнениеЗапросовПоСтрокам(Параметры.НастройкаТеста, Параметры.ВыделенныеСтроки, Параметры.ПараметрыТеста);
	ПоместитьВоВременноеХранилище(Результат, АдресХранилища);

КонецПроцедуры

Функция ВыполнениеЗапросовПоСтрокам(НастройкаТеста, ВыделенныеСтроки, ПараметрыТеста = Неопределено) Экспорт 

	Результат = НастройкаТестовСервер.РезультатВыполненияФоновогоЗаданияЭтапа();
	Если ПараметрыТеста = Неопределено Тогда
		ПараметрыТеста = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(НастройкаТеста, "СтрокаПодключенияКPostgres,КоэффициентОжиданияВыполненияЗапросовНаPostgres,МинимальнаяДлительностьВыполненияЗапроса");
	КонецЕсли;
	
	Попытка
		
		ДопТаблицы = Новый Структура("ВременныеТаблицыPostgres,ЭтапОбработки");
		ДопТаблицы.Вставить("Многопоточность", Ложь);
		ДопТаблицы.Вставить("ПараметрыТеста", ПараметрыТеста);
		ДопТаблицы.Вставить("Соединения", Новый Соответствие);
		ДопТаблицы.Вставить("НастройкаТеста", НастройкаТеста);
		ДопТаблицы.Вставить("ДатаНачала", ТекущаяУниверсальнаяДатаВМиллисекундах());
		
		ДлительныеОперации.СообщитьПрогресс(, "Подготовка вспомогательных таблиц");
	
		// Подготовим ТаблицаРезультатов и заполним ее из переданных выделенных строк
		ТаблицаРезультатов = РегистрыСведений.РезультатыВыполненияЗапросов.СоздатьНаборЗаписей().ВыгрузитьКолонки();
		НужныВТ = Ложь; // Признак что нужны ВременныеТаблицыPostgres
		Для каждого Строка Из ВыделенныеСтроки Цикл
			
			МенеджерЗаписи = РегистрыСведений.РезультатыВыполненияЗапросов.СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(МенеджерЗаписи, Строка);
			МенеджерЗаписи.Прочитать(); 
			
			Если Не ЗначениеЗаполнено(МенеджерЗаписи.ВидОшибки) Или МенеджерЗаписи.ВидОшибки = Перечисления.ВидыОшибокЗапросов.ОшибкаPostgres Тогда
				
				НоваяСтрока = ТаблицаРезультатов.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, МенеджерЗаписи,,"ВидОшибки,ТекстОшибки"); 
				
				Если Не НужныВТ Тогда
					Если 	МенеджерЗаписи.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы 
							Или МенеджерЗаписи.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ОчисткаВременнойТаблицы 
							Или МенеджерЗаписи.ВидСобытия = Перечисления.ВидыСобытийЗапросов.СозданиеВременнойТаблицы 
							Или СтрНайтиПоРегулярномуВыражению(МенеджерЗаписи.ТекстЗапросаPostgres, "\b(pg_temp\.tt\d+)\b").НачальнаяПозиция > 0 Тогда
							
						НужныВТ = Истина;
						
					КонецЕсли;	
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если НужныВТ Тогда
			
			ВременныеТаблицыPostgres = НастройкаТестов_СозданиеВременныхТаблиц.ВременныеТаблицыPostgres(НастройкаТеста);
			ВременныеТаблицыPostgres.Колонки.Добавить("Создана", Новый ОписаниеТипов("Булево"));
			Если Не ЗначениеЗаполнено(ВременныеТаблицыPostgres) Тогда
				ТекстОшибки = "Нет данных по временным таблицам Postgres!";
				ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
				Результат.ОписаниеОшибки = ТекстОшибки;
				Возврат Результат;
			КонецЕсли;
			
			ВременныеТаблицыPostgres.Индексы.Добавить("НомерСессии, ИмяТаблицы"); // Для поиска при создании ВТ
			ДопТаблицы.Вставить("ВременныеТаблицыPostgres", ВременныеТаблицыPostgres);
			
		КонецЕсли;
		ТаблицаРезультатов.ЗаполнитьЗначения(Перечисления.ВидыОшибокЗапросов.ПустаяСсылка(), "ВидОшибки");
		ТаблицаРезультатов.ЗаполнитьЗначения(Справочники.ОшибкиПриВыполнени.ПустаяСсылка(), "ОшибкаПриВыполнения");
		ТаблицаРезультатов.Сортировать("ДатаСобытия,НомерСессии,НомерСобытия");
		
		ОбработатьСтрокиТаблицыРезультатов(НастройкаТеста, ТаблицаРезультатов, ДопТаблицы, "Выполнение запросов по выделенным строкам");	
		
	Исключение
		
		НастройкаТестовСервер.СообщитьОшибку(НастройкаТеста, "ВыполнениеЗапросовПОВыделеннымСтрокак", ИнформацияОбОшибке(), Результат);
		
	КонецПопытки;
	
	ЗакрытьСоединение(НастройкаТеста, ДопТаблицы.Соединения, Результат); 
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти 

#Область СлужебныеПроцедурыИФункции 

Процедура ОбработатьСтрокиТаблицыРезультатов(НастройкаТеста, ТаблицаРезультатов, ДопТаблицы, ТекстСообщения, ЗаголовокСообщения = "")
    Перем ДатаНач;
	
    Команда = Новый COMОбъект("ADODB.Command");
    Выборка = Новый COMОбъект("ADODB.RecordSet");
	Шагов = 10;
	Шаг = Цел(ТаблицаРезультатов.Количество() / Шагов) - 1; 
	Если Шаг = 0 Тогда
		Шаг = 1;	
	КонецЕсли;
	Сч = 0;

	Для каждого СтрокаТаблицы Из ТаблицаРезультатов Цикл
										 
		Если Сч % Шаг = 0 Тогда
			НастройкаТестовСервер.СообщитьПрогрессаЭтапа(ТекстСообщения, ЗаголовокСообщения, Окр(Сч/ТаблицаРезультатов.Количество()*100, 0));
		КонецЕсли;
		Сч = Сч + 1;
		
		НастройкаТестовСервер.ЗаписьОтладки(НастройкаТеста, , СтрокаТаблицы.НомерСессии, СтрокаТаблицы.НомерСобытия);
		
		Соединение = ПолучитьСоединение(СтрокаТаблицы.НомерСессии, ДопТаблицы, Команда);
		Команда.ActiveConnection = Соединение;
		
		// Добавим в имена ВТ Номер сессии
		ТекстЗапросаPostgres = СтрЗаменитьПоРегулярномуВыражению(СтрокаТаблицы.ТекстЗапросаPostgres, "\b(pg_temp\.tt\d+)\b", СтрШаблон("$1_%1", Формат(СтрокаТаблицы.НомерСессии, "ЧГ=0")));
		
		// Если это создание ВТ, то нужно проверить что предыдущая ВТ не действует, если так, то нужно ее удалить
		Если 	СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.СозданиеВременнойТаблицы") 
				Или СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы") 
				Или СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ОчисткаВременнойТаблицы") 
				Или СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ОпределениеПодготовленногоОператораВТ") 
				Тогда
				
			Если СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.СозданиеВременнойТаблицы") Тогда
				Шаблон = "CREATE TEMPORARY TABLE pg_temp.";
			ИначеЕсли СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы") 
					Или СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ОпределениеПодготовленногоОператораВТ") Тогда
				Шаблон = "insert into pg_temp.";
			Иначе
				Шаблон = "pg_temp.";
			КонецЕсли;
			ИмяТаблицы = НастройкаТестов_СозданиеВременныхТаблиц.ИмяВТ(ТекстЗапросаPostgres, Шаблон, Истина);
			ИмяВТБезСессии = ИмяВТБезСессии(ИмяТаблицы);

			Строки = НастройкаТестов_СозданиеВременныхТаблиц.СтрокиВременныеТаблицыPostgres(ДопТаблицы.ВременныеТаблицыPostgres, СтрокаТаблицы.НомерСессии, ИмяВТБезСессии);
			ЕстьОшибка = Ложь;
			ПредыдущаяСтрока = Неопределено;
			
			Если СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.СозданиеВременнойТаблицы") Тогда 
			
				// Возможно есть предыдующая ВТ, если ВТ по ней создана, то ее нужо будет удалить
				Для каждого Строка Из Строки Цикл
					
					Если Строка.ДатаСоздания = СтрокаТаблицы.ДатаСобытия И Строка.НомерСобытия = СтрокаТаблицы.НомерСобытия Тогда
						Прервать;	
					КонецЕсли;	
					
					ПредыдущаяСтрока = Строка;
					
				КонецЦикла;
				
				Строка.Создана = Истина;
				
				// Проверяем, что бы в предыдущей строке не было флага Создана, если есть, то удаляем прошлую ВТ
				Если ПредыдущаяСтрока <> Неопределено И ПредыдущаяСтрока.Создана Тогда
					
					ПредыдущаяСтрока.Создана = Ложь;
					Если ЗначениеЗаполнено(ДопТаблицы.ПараметрыТеста.КоэффициентОжиданияВыполненияЗапросовНаPostgres) Тогда
						Команда.CommandText = "SET statement_timeout to 5000"; // Если не задан коэф, то устанавливаем длителность в 5 секунд для простых запросов Произошла исключительная ситуация (Microsoft OLE DB Provider for ODBC Drivers): ERROR: canceling statement due to statement timeout;
				        Выборка = Команда.Execute();
					КонецЕсли;
					ТекстЗапроса = СтрШаблон("DROP TABLE pg_temp.%1", ИмяТаблицы);
					ТекстОшибки = "Ошибка при выполнении предварительного запроса удаления предыдущей версии ВТ";
					ЕстьОшибка = Не ВыполнитьЗапрос(Команда, Выборка, ТекстЗапроса, ДатаНач, СтрокаТаблицы, ДопТаблицы, ТекстОшибки);
					
					Если ЕстьОшибка Тогда
						Продолжить;	
					КонецЕсли;
					
				КонецЕсли;
			
			// Для заполнения ВТ проверяется необходимость создания ВТ и первоначальный подсчет строк в ней, если она уже существует
			ИначеЕсли СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы")
					Или СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ОпределениеПодготовленногоОператораВТ") 
					// Если это очистка ВТ, но ВТ еще не создана, то пропускаем
					ИЛИ СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ОчисткаВременнойТаблицы") Тогда
			
				// Ищем подходящую строку для создания скрипта ВТ
				СтрокаСозданияСкрипта = Неопределено;
				Для каждого Строка Из Строки Цикл
					
					Если Строка.ДатаСоздания = СтрокаТаблицы.ДатаСобытия И Строка.НомерСобытия = СтрокаТаблицы.НомерСобытия Тогда
						СтрокаСозданияСкрипта = Строка;
						Прервать;
					ИначеЕсли Строка.ДатаСоздания > СтрокаТаблицы.ДатаСобытия Тогда
						Если СтрокаСозданияСкрипта = Неопределено Тогда
							СтрокаСозданияСкрипта = Строка;
						КонецЕсли;
						Прервать;	
					КонецЕсли;	
					
					СтрокаСозданияСкрипта = Строка;
								
				КонецЦикла;
				
			КонецЕсли;
			
			Если СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы") 
				Или СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ОпределениеПодготовленногоОператораВТ") Тогда
			
				ТекстЗапросаКоличества = СтрШаблон("SELECT COUNT(*) FROM pg_temp.%1", ИмяТаблицы);
				// Если требуемая ВТ не создана, то создаем ее по скрипту или подсчитываем количество строк в уже созданной ВТ перед выполнением основного запроса по инсерту
				Если Не СтрокаСозданияСкрипта.Создана Тогда
					СтрокаСозданияСкрипта.Создана = Истина;
					СкриптСоздания = СтрЗаменить(СтрокаСозданияСкрипта.СкриптСоздания, ИмяВТБезСессии, ИмяТаблицы);
					Если ЗначениеЗаполнено(ДопТаблицы.ПараметрыТеста.КоэффициентОжиданияВыполненияЗапросовНаPostgres) Тогда
						Команда.CommandText = "SET statement_timeout to 5000"; // Если не задан коэф, то устанавливаем длителность в 5 секунд для простых запросов Произошла исключительная ситуация (Microsoft OLE DB Provider for ODBC Drivers): ERROR: canceling statement due to statement timeout;
				        Выборка = Команда.Execute();
					КонецЕсли;
					ЕстьОшибка = Не ВыполнитьЗапрос(Команда, Выборка, СкриптСоздания, ДатаНач, СтрокаТаблицы, ДопТаблицы, "Ошибка при выполнении предварительного запроса создания ВТ");
				Иначе	
					ТекстОшибки = "Ошибка при выполнении предварительного запроса первого подсчета строк ВТ";
					Если ЗначениеЗаполнено(ДопТаблицы.ПараметрыТеста.КоэффициентОжиданияВыполненияЗапросовНаPostgres) Тогда
						Команда.CommandText = "SET statement_timeout to 50000"; // Если не задан коэф, то устанавливаем длителность в 5 секунд для простых запросов Произошла исключительная ситуация (Microsoft OLE DB Provider for ODBC Drivers): ERROR: canceling statement due to statement timeout;
				        Выборка = Команда.Execute();
					КонецЕсли;
					ЕстьОшибка = Не ВыполнитьЗапрос(Команда, Выборка, ТекстЗапросаКоличества, ДатаНач, СтрокаТаблицы, ДопТаблицы, ТекстОшибки);
					Если Не ЕстьОшибка Тогда
						СтрокаТаблицы.КоличествоСтрокPostgres = Выборка.Fields("count").value;
					КонецЕсли;
				КонецЕсли;
				
				Если ЕстьОшибка Тогда
					Продолжить;	
				КонецЕсли;
			ИначеЕсли (СтрокаСозданияСкрипта = Неопределено Или Не СтрокаСозданияСкрипта.Создана) И СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ОчисткаВременнойТаблицы") Тогда
				
				СтрокаТаблицы.ВидОшибки = Перечисления.ВидыОшибокЗапросов.ОшибочноеИспользованиеВТ;
				ТекстОшибки = СтрШаблон("Таблица %1 еще не создана или есть ошибка ее создания", ИмяТаблицы);
				НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, ТекстОшибки, Истина);
				Продолжить;
				
			КонецЕсли;	
			
		КонецЕсли;
		
		// Пробуем выполнить запрос в цикле, при ошибке пробуем исправить и еще раз выполнить до тех пор пока будет выполняться без ошибок, либо пока ошибки не смогут исправляться
		Если ЗначениеЗаполнено(ДопТаблицы.ПараметрыТеста.КоэффициентОжиданияВыполненияЗапросовНаPostgres) Тогда
			Длительность = Макс(СтрокаТаблицы.ДлительностьВыполненияMSSQL * ДопТаблицы.ПараметрыТеста.КоэффициентОжиданияВыполненияЗапросовНаPostgres, 
				ДопТаблицы.ПараметрыТеста.МинимальнаяДлительностьВыполненияЗапроса);
			Команда.CommandText = СтрШаблон("SET statement_timeout to %1", Формат(Длительность, "ЧГ=0")); // Если не задан коэф, то устанавливаем длителность в сутки Произошла исключительная ситуация (Microsoft OLE DB Provider for ODBC Drivers): ERROR: canceling statement due to statement timeout;
	        Выборка = Команда.Execute();
		КонецЕсли; 
		
		Если Не ВыполнитьЗапрос(Команда, Выборка, ТекстЗапросаPostgres, ДатаНач, СтрокаТаблицы, ДопТаблицы) Тогда
			Продолжить;	
		КонецЕсли;
		
		ДатаОкончания = ТекущаяУниверсальнаяДатаВМиллисекундах();
		СтрокаТаблицы.ДлительностьВыполненияPostgres = ДатаОкончания - ДатаНач;
		
		Если СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ВыборкаДанных") Тогда
			
			Попытка
				СтрокаТаблицы.КоличествоСтрокPostgres = Выборка.RecordCount;
			Исключение
				СтрокаТаблицы.ОшибкаПриВыполнения = Справочники.ОшибкиПриВыполнени.ОшибкаПриПодсчетеКоличестваСтрокРезультатаЗапроса;
				ТекстОшибки = "Не удалось подсчитать количество строк по ошибке нехватки памяти"; 
			КонецПопытки; 
			
		ИначеЕсли СтрокаТаблицы.ВидСобытия = ПредопределенноеЗначение("Перечисление.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы") Тогда
			
			ТекстОшибки = "Ошибка при выполнении запроса подсчета строк ВТ после выполнения основного запроса";
			Если ЗначениеЗаполнено(ДопТаблицы.ПараметрыТеста.КоэффициентОжиданияВыполненияЗапросовНаPostgres) Тогда
				Команда.CommandText = "SET statement_timeout to 5000"; // Если не задан коэф, то устанавливаем длителность в 5 секунд для простых запросов Произошла исключительная ситуация (Microsoft OLE DB Provider for ODBC Drivers): ERROR: canceling statement due to statement timeout;
		        Выборка = Команда.Execute();
			КонецЕсли;
			ЕстьОшибка = Не ВыполнитьЗапрос(Команда, Выборка, ТекстЗапросаКоличества, ДатаНач, СтрокаТаблицы, ДопТаблицы, ТекстОшибки);
			Если ЕстьОшибка Тогда
				Продолжить;	
			КонецЕсли;
			СтрокаТаблицы.КоличествоСтрокPostgres = Выборка.Fields("count").value - СтрокаТаблицы.КоличествоСтрокPostgres;
					
		КонецЕсли;
		
	КонецЦикла; 
	
	Попытка
		НачатьТранзакцию();
		НастройкаТестовСервер.ЗагрузитьДанныеВРегистр(НастройкаТеста, ТаблицаРезультатов);
		
		Если ДопТаблицы.ВременныеТаблицыPostgres <> Неопределено Тогда
			НастройкаТестов_СозданиеВременныхТаблиц.СохранитьВременнуюТаблицы(НастройкаТеста, ДопТаблицы.ВременныеТаблицыPostgres, "ВременныеТаблицыPostgres");
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
	    ОтменитьТранзакцию();
		ВызватьИсключение("Ошибка загрузки данных в регистр " + ОписаниеОшибки());
	КонецПопытки;
	
	ТаблицаРезультатов = Неопределено; 
	
КонецПроцедуры

Функция ВыполнитьЗапрос(Команда, Выборка, ТекстЗапроса, ДатаНач, СтрокаТаблицы, ДопТаблицы, ЗаголовокОшибки = "Ошибка при выполнении основного запроса")
	
	ЗапросВыполнен = Ложь;
	
	Пока Истина Цикл
		
		Попытка
			
	        Команда.CommandText = ТекстЗапроса; 
			ДатаНач = ТекущаяУниверсальнаяДатаВМиллисекундах();
	        Выборка = Команда.Execute(); 
			ЗапросВыполнен = Истина;
			
			Прервать;
			
		Исключение
			
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ОписаниеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			
			ТекстОшибки = "";
			ОшибкаИсправлена = Ложь;
			
			// Если это ошибка вида: Произошла исключительная ситуация (Microsoft OLE DB Provider for ODBC Drivers): ERROR: relation "pg_temp.tt153" does not exist;
			// Error while executing the query
			// то скорее всего это самое начало логов. В текущем запросе требуется таблица. Скрипт создания таблицы не ошибочных. Был инсерт в требуемую таблицу, но в том инсерте так же была использована какая то ВТ для которой выше не было ни одной строки создания или инсера (Первые инсетры только ниже). Поэтому тот инсерт стал связанным запросом 
			// Строка с инсертом в требумую таблицу была помечена как связаный запрос, но скрипт создания ВТ не ошибочный. Что бы не заморачиваться и не уставливать в текущем запросе связаный запрос создадим ВТ тут.  
			// По хорошему нужно отслеживать опусошения таблиц и для периода до первого опустошения такие запросы нужно помечать как связанные
			
			// Создадим ВТ, но зафиксируем информацию.
			СтрокаПоиска = "[.\s\S]*relation ""pg_temp.((tt\d+)_\d+)"" does not exist;";
			Результат = СтрНайтиПоРегулярномуВыражению(ОписаниеОшибки, СтрокаПоиска);
			Если Результат.НачальнаяПозиция > 0 Тогда
				
				ИмяТаблицы = Результат.ПолучитьГруппы()[0].Значение;
				ИмяВТБезСессии = Результат.ПолучитьГруппы()[1].Значение;
				Если ЗначениеЗаполнено(ИмяВТБезСессии) Тогда
					
					Строки = НастройкаТестов_СозданиеВременныхТаблиц.СтрокиВременныеТаблицыPostgres(ДопТаблицы.ВременныеТаблицыPostgres, СтрокаТаблицы.НомерСессии, ИмяВТБезСессии);
					СтрокаСозданияСкрипта = Неопределено;
					Для каждого Строка Из Строки Цикл
						Если Строка.ДатаСоздания > СтрокаТаблицы.ДатаСобытия Тогда
							Прервать;	
						КонецЕсли;	
						СтрокаСозданияСкрипта = Строка;
					КонецЦикла; 
					
					// Если реально ВТ создается Позже - начало логов
					Если СтрокаСозданияСкрипта = Неопределено И Строки.Количество() > 0 Тогда
						Для каждого Строка  Из Строки Цикл
							Если Строка.Создана = Истина Тогда
								Прервать;	
							КонецЕсли;	
						КонецЦикла;	     
						Если Не Строка.Создана Тогда
							СтрокаСозданияСкрипта = Строка;
						КонецЕсли;
					КонецЕсли;
					
					Если СтрокаСозданияСкрипта = Неопределено Тогда
						
						ТекстОшибки = СтрШаблон("В запросе требуется ВТ %1. Но почему то подходящая ВТ не найдена", ИмяТаблицы);
						СтрокаТаблицы.ОшибкаПриВыполнения = Справочники.ОшибкиПриВыполнени.НеНайденаПодходящаяВТ;
						
					ИначеЕсли СтрокаСозданияСкрипта.ОшибкаСоздания = Истина Тогда
						
						СтрокаТаблицы.ОшибкаПриВыполнения = Справочники.ОшибкиПриВыполнени.ЗапросНеПопалВСвязанныеПриОшибкеВТ;
						ТекстОшибки = СтрШаблон("В запросе требуется ВТ %1. У нее выставлена ошибка создания, но текущий запрос не попал в связанные запросы.", ИмяТаблицы); 

					ИначеЕсли ЗначениеЗаполнено(СтрокаСозданияСкрипта.ОшибкаВыполнения) Тогда
						
						ТекстОшибки = СтрШаблон("В запросе требуется ВТ %1. Ошибка выполнения скрипта при ее создании: %2", ИмяТаблицы, СтрокаСозданияСкрипта.ОшибкаВыполнения);
						СтрокаТаблицы.ОшибкаПриВыполнения = Справочники.ОшибкиПриВыполнени.ОшибкаВыполненияСкриптаСозданияВТ;
						СтрокаСозданияСкрипта.ВидИзменения = 2;
						
					// Создаем ВТ, но фиксируем инфу	
					Иначе
						
						Попытка
							СкриптСоздания = СтрЗаменить(СтрокаСозданияСкрипта.СкриптСоздания, ИмяВТБезСессии, ИмяТаблицы);
							Текст = СтрЗаменитьПоРегулярномуВыражению(СкриптСоздания, "\b(pg_temp\.tt\d+)\b", СтрШаблон("$1_%1", Формат(СтрокаТаблицы.НомерСессии, "ЧГ=0"))); 
							СтрокаСозданияСкрипта.Создана = Истина;
							СтрокаСозданияСкрипта.ДатаСоздания = СтрокаТаблицы.ДатаСобытия;
							СтрокаСозданияСкрипта.НомерСобытия = СтрокаТаблицы.НомерСобытия;
							Если ЗначениеЗаполнено(ДопТаблицы.ПараметрыТеста.КоэффициентОжиданияВыполненияЗапросовНаPostgres) Тогда
								Команда.CommandText = "SET statement_timeout to 5000"; // Если не задан коэф, то устанавливаем длителность в 5 секунд для простых запросов Произошла исключительная ситуация (Microsoft OLE DB Provider for ODBC Drivers): ERROR: canceling statement due to statement timeout;
						        Выборка = Команда.Execute();
							КонецЕсли;
					        Команда.CommandText = Текст;
					        Выборка = Команда.Execute();
							ОшибкаИсправлена = Истина;
							Текст = СтрШаблон("В запросе требуется ВТ %1. Скорее всего это начало логов и запрос создания ВТ не попал. ВТ создана, запрос выполнен, но т.к. ВТ %1 не заполнена, то результат текущего запроса некорректен", ИмяТаблицы);
							НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, Текст, Истина);
							СтрокаТаблицы.ВидОшибки = ПредопределенноеЗначение("Перечисление.ВидыОшибокЗапросов.ОшибочноеИспользованиеВТ");
						Исключение
							Информация = ИнформацияОбОшибке();
							СтрокаСозданияСкрипта.ОшибкаВыполнения = КраткоеПредставлениеОшибки(Информация);
							СтрокаСозданияСкрипта.ВидИзменения = 2;
							ТекстОшибки = СтрШаблон("В запросе требуется ВТ %1. Ошибка скрипта при ее создании: %2", ИмяТаблицы, КраткоеПредставлениеОшибки(Информация));
						КонецПопытки;
						
					КонецЕсли; 

				КонецЕсли;
				
			ИначеЕсли СтрНайти(ОписаниеОшибки, "canceling statement due to statement timeout") > 0 Тогда
				
				СтрокаТаблицы.ОшибкаПриВыполнения = Справочники.ОшибкиПриВыполнени.НеВыполнилсяПоТаймауту;
				ТекстЗапроса = СтрШаблон("EXPLAIN (FORMAT JSON) %1", ТекстЗапроса);
				Команда.CommandText = ТекстЗапроса; 
		        Выборка = Команда.Execute(); 
				
				Если Выборка.BOF = Ложь Тогда
					
					Выборка.MoveFirst(); 
					ПланЗапроса = Выборка.Fields("QUERY PLAN").value;
					СтрокаТаблицы.ТекстОшибки = ?(ПустаяСтрока(СтрокаТаблицы.ТекстОшибки), "", СтрШаблон("%1%2", СтрокаТаблицы.ТекстОшибки, Символы.ПС));
					СтрокаТаблицы.ТекстОшибки = СтрШаблон("%1План запроса:%2%3", СтрокаТаблицы.ТекстОшибки, Символы.ПС, ПланЗапроса);
					
				КонецЕсли;
				
				Прервать;
				
			КонецЕсли;
			
			// Если поймали ошибку при исправлении, то дальше можно не продолжать
			Если ЗначениеЗаполнено(ТекстОшибки) Тогда
				НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, ТекстОшибки, Истина);
				Прервать;
			КонецЕсли;
			
			// Если ошибку не смогли исправить, то дальше можно не продолжать
			Если Не ОшибкаИсправлена Тогда
				Прервать;
			КонецЕсли;
			
		КонецПопытки;
			
	КонецЦикла; 
	
	Если Не ЗапросВыполнен И СтрокаТаблицы.ОшибкаПриВыполнения <> Справочники.ОшибкиПриВыполнени.НеВыполнилсяПоТаймауту Тогда
        НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, СтрШаблон("%1: %2", ЗаголовокОшибки, ОписаниеОшибки));
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ВидОшибки) Тогда
			СтрокаТаблицы.ВидОшибки = ПредопределенноеЗначение("Перечисление.ВидыОшибокЗапросов.ОшибкаPostgres");
		КонецЕсли;
	КонецЕсли; 
	
	Возврат ЗапросВыполнен;
		
КонецФункции

Функция ПолучитьСоединение(НомерСессии, ДопТаблицы,Команда) Экспорт 
	
	Соединение = ДопТаблицы.Соединения.Получить(НомерСессии);
	
	Если Соединение = Неопределено Тогда
		
		Соединение  = Новый COMОбъект("ADODB.Connection");
        Соединение.ConnectionString = ДопТаблицы.ПараметрыТеста.СтрокаПодключенияКPostgres;
		Соединение.ConnectionTimeout = 30;
		Соединение.CommandTimeout = 600;
		Соединение.CursorLocation = 3;
		
		Соединение.Open();
		
		ДопТаблицы.Соединения.Вставить(НомерСессии, Соединение);
		
		Команда.ActiveConnection = Соединение;
		Запросы = Новый Массив;
		Запросы.Добавить("SET client_min_messages=error");
		Запросы.Добавить("SET lc_messages to 'en_US.UTF-8'");
		Запросы.Добавить("SET enable_mergejoin=off");
		Запросы.Добавить("SET escape_string_warning=off");
		Запросы.Добавить("SET cpu_operator_cost=0.001");
		Запросы.Добавить("SET client_encoding='utf8'");
		Запросы.Добавить("SET lock_timeout=20000");
		
		Если Не ЗначениеЗаполнено(ДопТаблицы.ПараметрыТеста.КоэффициентОжиданияВыполненияЗапросовНаPostgres) Тогда
			Запросы.Добавить("SET statement_timeout to 86400000"); // Если не задан коэф, то устанавливаем длителность в сутки Произошла исключительная ситуация (Microsoft OLE DB Provider for ODBC Drivers): ERROR: canceling statement due to statement timeout;
		КонецЕсли;
		
		Для каждого ТекстЗапроса Из Запросы Цикл
	        Команда.CommandText = ТекстЗапроса; 
	        Команда.Execute();
		КонецЦикла;
		
	КонецЕсли; 
	
	Возврат Соединение;
	
КонецФункции

Процедура ЗакрытьСоединение(НастройкаТеста, Соединения, Результат)
    /////////////////////////////////////////
    //Закрытия соединения
	Если ЗначениеЗаполнено(Соединения) Тогда
		Для каждого КиЗ Из Соединения Цикл
			Если КиЗ.Значение <> Неопределено Тогда
				Попытка
			        КиЗ.Значение.Close();
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
					НастройкаТестовСервер.СообщитьОшибку(НастройкаТеста, "ВыполнениеЗапросов", ИнформацияОбОшибке, Результат);
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Функция ИмяВТсСессией(ИмяВТ, НомерСессии)
	
	Результат = СтрШаблон("%1_%2", ИмяВТ, Формат(НомерСессии, "ЧРД="));
	Возврат Результат;
	
КонецФункции

Функция ИмяВТБезСессии(ИмяВТсСессией) 
	
	Результат = СтрНайтиПоРегулярномуВыражению(ИмяВТсСессией, "(tt\d+)_\d+").ПолучитьГруппы()[0].Значение;
	Возврат Результат;
	
КонецФункции

Процедура ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы, НомераСессий = Неопределено)
	
	Если ЗначениеЗаполнено(НомераСессий) Тогда
		Отборы = "НомерСессии В (&НомераСессий)";
		Параметры = Новый Структура("НомераСессий", НомераСессий);
	Иначе
		Отборы = ""; 
		Параметры = Неопределено; 
	КонецЕсли;
	
	ДопТаблицы.Вставить("ВременныеТаблицыPostgres", НастройкаТестов_СозданиеВременныхТаблиц.ВременныеТаблицыPostgres(НастройкаТеста, , Отборы, Параметры)); 
	Если ДопТаблицы.ОчиститьЭтап Тогда
		ДопТаблицы.ВременныеТаблицыPostgres.ЗаполнитьЗначения("", "ОшибкаВыполнения");
	КонецЕсли;
	
	ДопТаблицы.ВременныеТаблицыPostgres.Индексы.Добавить("НомерСессии,ИмяТаблицы");
	ДопТаблицы.ВременныеТаблицыPostgres.Колонки.Добавить("Создана", Новый ОписаниеТипов("Булево"));
		
КонецПроцедуры

Процедура ВыполнитьОдинПоток(НастройкаТеста, ТаблицаРезультатов = Неопределено, ДопТаблицы) Экспорт	
	
	Если ТаблицаРезультатов = Неопределено Тогда
		ТаблицаРезультатов = НастройкаТестовСервер.ТаблицаРезультатов(НастройкаТеста, ДопТаблицы);
	КонецЕсли;
	ТаблицаРезультатов.ЗаполнитьЗначения(Перечисления.ВидыОшибокЗапросов.ПустаяСсылка(), "ВидОшибки");
	ТаблицаРезультатов.ЗаполнитьЗначения(Справочники.ОшибкиПриВыполнени.ПустаяСсылка(), "ОшибкаПриВыполнения");
	
	Если ДопТаблицы.Многопоточность Тогда
		ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы, ДопТаблицы.Отборы.ОтборПоСессиям);
	КонецЕсли;
	
	// Основной цикл по строкам ТаблицаРезультатов
	ОбработатьСтрокиТаблицыРезультатов(НастройкаТеста, ТаблицаРезультатов, ДопТаблицы, ДопТаблицы.ТекстСообщения, ДопТаблицы.ЗаголовокСообщения);
			
КонецПроцедуры

#КонецОбласти