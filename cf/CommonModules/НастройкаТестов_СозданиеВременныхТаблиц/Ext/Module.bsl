#Область ПрограммныйИнтерфейс

Процедура СозданиеВременныхТаблицФон(Параметры, АдресХранилища) Экспорт 

	Результат = СозданиеВременныхТаблиц(Параметры.НастройкаТеста, Параметры.ОчиститьЭтап, Параметры.ПараметрыТеста);
	ПоместитьВоВременноеХранилище(Результат, АдресХранилища);

КонецПроцедуры

Функция СозданиеВременныхТаблиц(НастройкаТеста, ОчиститьЭтап, ПараметрыТеста = Неопределено) Экспорт 

	ДатаНачалаОбщая = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Результат = НастройкаТестовСервер.РезультатВыполненияФоновогоЗаданияЭтапа();
	Если ПараметрыТеста = Неопределено Тогда
		ПараметрыТеста = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(НастройкаТеста, "ИнтервалОбработкиДанных");
	КонецЕсли;
	
	Попытка
		
		ВТ = ВременныеТаблицыMSSQL(НастройкаТеста, Истина);
		Если Не ЗначениеЗаполнено(ВТ) Тогда
			
			ТекстОшибки = "Нет данных по временным таблицам!";
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
			Результат.ОписаниеОшибки = ТекстОшибки;
			
			Возврат Результат;
			
		КонецЕсли;
		
		Если Не ОчиститьЭтап Тогда
			ЭтапОбработки = НастройкаТестовСервер.ЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.СозданиеВременныхТаблиц);
			ОчиститьЭтап = ЭтапОбработки.НомерИтерации = 0;
		КонецЕсли;
		
		Если ОчиститьЭтап Тогда 
			
			НастройкаТестовСервер.ОчиститьЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.СозданиеВременныхТаблиц);
			НастройкаТестовСервер.ОчиститьЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.СозданиеТекстовЗапросов);
			НастройкаТестовСервер.ОчиститьЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.УстановкаСвязанныхЗапросов);
			НастройкаТестовСервер.ОчиститьЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.ВыполнениеЗапросов);
			НастройкаТестовСервер.УдалитьДанныеРегистровНастройкиТеста(НастройкаТеста, 4); 
			
		КонецЕсли;
		
		Многопоточность = НастройкаТестовСервер.Многопоточность();
		
		// Подготовим вспомогательные таблицы
		ДопТаблицы = Новый Структура;
		ДопТаблицы.Вставить("Многопоточность", 				Многопоточность);
		ДопТаблицы.Вставить("СоответствиеТиповДанных", 		НастройкаТестов_СозданиеЗапросов.ЗаполнитьСоответствиеТиповДанных());
		ДопТаблицы.Вставить("СоответствиеИменТиповДанных", 	СоответствиеИменТиповДанных());
		ДопТаблицы.Вставить("ОшибкиПреобразования", 		НастройкаТестов_СозданиеЗапросов.ОшибкиПреобразования());
		
		// Если рассчет не многопотоковый, то можно получить сразу все вспомогательные таблицы, которые зависят от сессий и наполняются при рассчетах
		Если Не Многопоточность Тогда
			ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы);
		КонецЕсли;
		
		ИсключитьВидОшибок = Новый Массив;
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ОшибкаMSSQL);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ПропущенныйЗапросMsSQL);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ПропускатьПриПреобразовании);
		
		ТолькоВидыСобытий = Новый Массив;
		ТолькоВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.СозданиеВременнойТаблицы);
		ТолькоВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы);
		ТолькоВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.ОчисткаВременнойТаблицы);
		ТолькоВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.СозданиеИндексаВременнойТаблицы);
		ТолькоВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.ОпределениеПодготовленногоОператораВТ);
		ТолькоВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.ВызовПодготовленногоОператораВТ);
		ТолькоВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.РазрушениеПодготовленногоОператораВТ);
		
		// Отдельная структура под отборы для получения данных из РС Результаты...
		Отборы = НастройкаТестовСервер.ОтборыТаблицыРезультатов();
		Отборы.ПараметрыТеста 		= ПараметрыТеста;
		Отборы.ИсключитьВидОшибок 	= ИсключитьВидОшибок;
		Отборы.ТолькоВидыСобытий	= ТолькоВидыСобытий;
		ДопТаблицы.Вставить("Отборы", Отборы);
		
		НастройкаТестовСервер.РасчетИтераций(НастройкаТеста, ДопТаблицы);
		
		Пока Истина Цикл
			
			ДатаНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
			ДопТаблицы.Вставить("ДатаНачала", ДатаНачала);
			ЭтапОбработки = НастройкаТестовСервер.ЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.СозданиеВременныхТаблиц, ДопТаблицы.НастройкиИтераций);
			ДопТаблицы.Вставить("ЭтапОбработки", ЭтапОбработки);
			
			Если ПараметрыТеста.ИнтервалОбработкиДанных = 0 Тогда 
				ЗаголовокСообщения = "Создание ВТ Postgres";
				ТекстСообщения = "Всех записей...";
			Иначе
				ЗаголовокСообщения = СтрШаблон("Создание ВТ. Итерация %1 из %2", ЭтапОбработки.НомерИтерации, ДопТаблицы.НастройкиИтераций.Итераций);
				ТекстСообщения = СтрШаблон("Обработка записей за %1 мин. с %2", ПараметрыТеста.ИнтервалОбработкиДанных, Формат(ЭтапОбработки.ТекущаяДатаСобытия, "ДЛФ=DT"));
			КонецЕсли;
			
			ДопТаблицы.Вставить("ЗаголовокСообщения", 	ЗаголовокСообщения);
			ДопТаблицы.Вставить("ТекстСообщения", 		ТекстСообщения);
			ДопТаблицы.Вставить("Метод", 				"НастройкаТестов_СозданиеВременныхТаблиц.ВыполнитьОдинПоток");
			ДопТаблицы.Вставить("ПредставлениеЭтапа", 	"Создание Временных таблиц");
			ДопТаблицы.Вставить("ПодразделЖР", 			"СозданиеВременныхТаблиц");
			
			// Подготовка к многопоточности
			Если Многопоточность Тогда
				МассивЗаданий = НастройкаТестовСервер.СоздатьЗапуститьПотоки(НастройкаТеста, Результат, ДопТаблицы);
				Если Результат.ОшибкаВыполнения Тогда
					Прервать;	
				КонецЕсли;
				ДопТаблицы.Вставить("МассивЗаданий", МассивЗаданий);
			КонецЕсли;
			
			НастройкаТестовСервер.ВыполнитьИтерациюЭтапа(НастройкаТеста, ДопТаблицы, Результат);
			
			Если Результат.ОшибкаВыполнения Или ДопТаблицы.ЭтапОбработки.Завершен Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЦикла;
		
		Если Не Результат.ОшибкаВыполнения Тогда
			НастройкаТестовСервер.СообщитьДлительностьОперации(НастройкаТеста,ДопТаблицы.ПредставлениеЭтапа, ДатаНачалаОбщая);
		   	НастройкаТестов_СозданиеЗапросов.СообщитьОбОшибкахОтладки(НастройкаТеста, "ОтладкаСозданияВТ"); 
		   	НастройкаТестов_СозданиеЗапросов.СообщитьОбОшибкахОтладки(НастройкаТеста, "ОтладкаПодготовленныхОператоров"); 
			Результат.Вставить("ЭтапЗавершен", Истина);
		КонецЕсли;
		
	Исключение
		
		НастройкаТестовСервер.СообщитьОшибку(НастройкаТеста, "СозданиеВременныхТаблиц", ИнформацияОбОшибке(), Результат, МассивЗаданий);
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти 

#Область СлужебныеПроцедурыИФункции 

Процедура ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы, НомераСессий = Неопределено)
	
	Если ЗначениеЗаполнено(НомераСессий) Тогда
		Отборы = "НомерСессии В (&НомераСессий)";
		Параметры = Новый Структура("НомераСессий", НомераСессий);
	Иначе
		Отборы = ""; 
		Параметры = Неопределено; 
	КонецЕсли;
	ВТ = ВременныеТаблицыMSSQL(НастройкаТеста);
	ДопТаблицы.Вставить("ВТ", ВТ);
	ДопТаблицы.Вставить("ВременныеТаблицыPostgres", 			ВременныеТаблицыPostgres(НастройкаТеста, , Отборы, Параметры));
	
	ДопТаблицы.Вставить("ПоляВременныхТаблицыPostgres", 		ДанныеРегистраДляИзменения(НастройкаТеста, "ПоляВременныхТаблицыPostgres", НомераСессий));
	
	// Переходящие данные между итерациями, когда был разрыв между создание ПО и разрушением его. Требуется для НаполненияВременныхТаблицPostgres где нужно знать имена ВТ.
	// Данные будут добавляться в момент создания ПО и удаляться при Разрушении ПО. Если останутся, то запишутся в РС
	ДопТаблицы.Вставить("ИменаВТПодготовленныхОператоров", 		ДанныеРегистраДляИзменения(НастройкаТеста, "ИменаВТПодготовленныхОператоров", НомераСессий)); 
	
	// В этой ВТ будем хранить данные по ВТ, которые используются в Подготовленных операторов. Т.е. сюда будут попадать данные при создании ПО и удаляться при разрушении его
	// Нужно для быстрого поиска, т.к. ожидается много выполнений ПО. И для каждого нужно будет выполнять поиск вначале в ВременныеТаблицыPostgres, что бы найти ДатаСоздания, 
	// а потом в ПоляВременныхТаблицыPostgres
	ДопТаблицы.Вставить("КолонкиВТПодготовленныхОператоров", 		ДанныеРегистраДляИзменения(НастройкаТеста, "КолонкиВТПодготовленныхОператоров", НомераСессий)); 
	
	// Индексы для поиска для Подготовленных операторов ВТ
	ДопТаблицы.ВременныеТаблицыPostgres.Индексы.Добавить("НомерСессии,ИмяТаблицы");
	ДопТаблицы.ПоляВременныхТаблицыPostgres.Индексы.Добавить("НомерСессии,ИмяТаблицы,ДатаСоздания,НомерСобытия");
	ДопТаблицы.ПоляВременныхТаблицыPostgres.Индексы.Добавить("НомерСессии,ИмяТаблицы");
	ДопТаблицы.ИменаВТПодготовленныхОператоров.Индексы.Добавить("НомерСессии,ИмяОператора,ДатаСоздания,НомерСобытия");
	ДопТаблицы.КолонкиВТПодготовленныхОператоров.Индексы.Добавить("НомерСессии,ИмяОператора");
		
КонецПроцедуры

Процедура ВыполнитьОдинПоток(НастройкаТеста, ТаблицаРезультатов = Неопределено, ДопТаблицы) Экспорт	
	
	Если ТаблицаРезультатов = Неопределено Тогда
		ТаблицаРезультатов = НастройкаТестовСервер.ТаблицаРезультатов(НастройкаТеста, ДопТаблицы);
	КонецЕсли;
	Если ТаблицаРезультатов.Количество() = 0 Тогда
		Возврат	
	КонецЕсли;
	НастройкаТестов_СозданиеЗапросов.ПодготовитьТаблицуРезультатов(ТаблицаРезультатов);
	ТаблицаРезультатов.Индексы.Добавить("НомерСессии,НомерСобытия");                                                                                           
	ДопТаблицы.Вставить("ТаблицаРезультатов", ТаблицаРезультатов);
	
	Если ДопТаблицы.Многопоточность Тогда
		ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы, ДопТаблицы.Отборы.ОтборПоСессиям);
	КонецЕсли;
	
	// Основной цикл по строкам ТаблицаРезультатов
	НастройкаТестов_СозданиеЗапросов.ОбработатьСтрокиТаблицыРезультатов(НастройкаТеста, ТаблицаРезультатов, ДопТаблицы, ДопТаблицы.ТекстСообщения, ДопТаблицы.ЗаголовокСообщения);
	
	// Сохранение изменненных таблиц в соответсвующие регистры
	
	Попытка
		НачатьТранзакцию();
		
		НастройкаТестовСервер.ЗагрузитьДанныеВРегистр(НастройкаТеста, ТаблицаРезультатов);
		СохранитьВременнуюТаблицы(НастройкаТеста, ДопТаблицы.ВременныеТаблицыPostgres, 				"ВременныеТаблицыPostgres", ДопТаблицы.Многопоточность);
		СохранитьВременнуюТаблицы(НастройкаТеста, ДопТаблицы.ПоляВременныхТаблицыPostgres, 			"ПоляВременныхТаблицыPostgres", ДопТаблицы.Многопоточность);
		ДопТаблицы.ИменаВТПодготовленныхОператоров.ЗаполнитьЗначения(НастройкаТеста, "НастройкаТеста");
		СохранитьВременнуюТаблицы(НастройкаТеста, ДопТаблицы.ИменаВТПодготовленныхОператоров, 		"ИменаВТПодготовленныхОператоров", ДопТаблицы.Многопоточность);
		ДопТаблицы.КолонкиВТПодготовленныхОператоров.ЗаполнитьЗначения(НастройкаТеста, "НастройкаТеста");
		СохранитьВременнуюТаблицы(НастройкаТеста, ДопТаблицы.КолонкиВТПодготовленныхОператоров, 	"КолонкиВТПодготовленныхОператоров", ДопТаблицы.Многопоточность);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение("Ошибка выполнения в один попток " + ОписаниеОшибки());
	КонецПопытки;
	
	ТаблицаРезультатов = Неопределено; 
		
КонецПроцедуры

Функция ИсправлениеОчисткиВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, Знач ТекстЗапроса, ДопТаблицы) Экспорт 
	
	// В логах PG очистка идет через функцию, поэтому делаю так же
	Результат = НастройкаТестов_СозданиеВременныхТаблиц.ИсправитьИменаВТЗапроса(ТекстЗапроса);
	СтрокаПоиска = "truncate table pg_temp.";
	ИмяТаблицы = НастройкаТестов_СозданиеВременныхТаблиц.ИмяВТ(Результат, СтрокаПоиска);
	
	Результат = СтрШаблон("SELECT FASTTRUNCATE ('%1')", СтрЗаменить(Результат, "truncate table ", ""));
	
	Возврат Результат;
	
КонецФункции

Функция СозданиеИндексаВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, Знач ТекстЗапроса, ДопТаблицы) Экспорт 
	
	// В логах PG очистка идет через функцию, поэтому делаю так же
	Результат = ИсправитьИменаВТЗапроса(ТекстЗапроса); 
	Кластерный = Ложь;
	Уникальный = Ложь; 
	
	Если СтрНайти(Результат, НРег("CREATE CLUSTERED INDEX ")) > 0 Тогда
		
		ПозИмя = СтрДлина("CREATE CLUSTERED INDEX ");
		Кластерный = Истина;
		
	ИначеЕсли СтрНайти(Результат, НРег("CREATE UNIQUE CLUSTERED INDEX ")) > 0 Тогда
		
		ПозИмя = СтрДлина("CREATE UNIQUE CLUSTERED INDEX ");
		Кластерный = Истина;
		Уникальный = Истина;
		
	Иначе           
		
		НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "НепонятныйВидИндекса",,ДопТаблицы.Многопоточность);
		
		Возврат ""; 
		
	КонецЕсли;
	
	ПозВТ = СтрНайти(Результат, НРег(" ON "));
	ИмяИндекса = Сред(Результат, ПозИмя + 1, ПозВТ - ПозИмя - 1);
	
	ПозВыражение = СтрНайти(Результат, " (",, ПозВТ);
	ИмяВТ = Сред(Результат, ПозВТ + СтрДлина(" ON "), ПозВыражение - ПозВТ - СтрДлина(" ON "));
	
	Выражение = Прав(Результат, СтрДлина(Результат) - ПозВыражение);
	Результат = СтрШаблон("CREATE %1INDEX %2 ON %3 %4", ?(Уникальный, "UNIQUE ", ""), ИмяИндекса, ИмяВТ, Выражение);
	
	Если Кластерный Тогда
		
		Результат = СтрШаблон("%1 ;%2CLUSTER %3 USING %4", Результат, Символы.ПС, ИмяВТ, ИмяИндекса);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ВременныеТаблицыMSSQL(НастройкаТеста, ТолькоПервые1 = Ложь) Экспорт 
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ //%Первые1%
	|	table_id КАК table_id,
	|	col_id КАК col_id,
	|	col_name КАК col_name,
	|	table_name КАК table_name,
	|	data_name КАК data_name,
	|	data_len КАК data_len,
	|	data_nullable КАК data_nullable,
	|	col_max КАК col_max,
	|	precision КАК precision,
	|	scale КАК scale
	|ИЗ
	|	РегистрСведений.ВременныеТаблицы КАК ВременныеТаблицы
	|ГДЕ
	|	НастройкаТеста = &НастройкаТеста
	|";
	
	Если ТолькоПервые1 Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "//%Первые1%", "ПЕРВЫЕ 1");	
	КонецЕсли;
	Запрос.УстановитьПараметр("НастройкаТеста", НастройкаТеста);
	РезультатЗапроса = Запрос.Выполнить();
	
	ВТ = РезультатЗапроса.Выгрузить();
	ВТ.Индексы.Добавить("table_name,col_max"); 
	
 	Возврат ВТ;
	
КонецФункции

Функция ВременныеТаблицыPostgres(	НастройкаТеста, 
									Реквизиты = "*", 
									Отборы = "", 
									Параметры = Неопределено, 
									Порядок = "НастройкаТеста,НомерСессии,ИмяТаблицы,ДатаСоздания",
									Первые1 = 0) Экспорт

	Отборы = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"%1%2 НастройкаТеста = &НастройкаТеста",
		Отборы,
		?(ПустаяСтрока(Отборы), "", " И"));
	Если Не ТипЗнч(Параметры) = Тип("Структура") Тогда
		Параметры = Новый Структура;	
	КонецЕсли;
	Параметры.Вставить("НастройкаТеста", НастройкаТеста);
	
	РезультатЗапроса = ИТМ_ОбщегоНазначенияСервер.ПолучитьРезультатЗапросаПоТаблице(
		"РегистрСведений.ВременныеТаблицыPostgres",
		Первые1,,,
		Реквизиты,
		Отборы,
		Параметры,
		Порядок);

	Результат = РезультатЗапроса.Выгрузить();
	НастройкаТестовСервер.ДобавитьКолонкиИзмененияВТаблицу(Результат);
	
	Возврат Результат;
	
КонецФункции

Функция ДанныеРегистраДляИзменения(НастройкаТеста, ИмяРегистра, НомераСессий = Неопределено) Экспорт 
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|   *
	|ИЗ
	|  	РегистрСведений.ПоляВременныхТаблицыPostgres
	|ГДЕ
	|	НастройкаТеста = &НастройкаТеста
	|	//%НомераСессий%
	|";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ПоляВременныхТаблицыPostgres", ИмяРегистра); 
	Если ЗначениеЗаполнено(НомераСессий) Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "//%НомераСессий%", "И НомерСессии В(&НомераСессий)"); 
		Запрос.УстановитьПараметр("НомераСессий", НомераСессий);
	КонецЕсли;
	
	Запрос.УстановитьПараметр("НастройкаТеста", НастройкаТеста);
	РезультатЗапроса = Запрос.Выполнить();
	Результат = РезультатЗапроса.Выгрузить();
	НастройкаТестовСервер.ДобавитьКолонкиИзмененияВТаблицу(Результат);
	
	Возврат Результат;
	
КонецФункции

Функция ИсправитьИменаВТЗапроса(Знач ТекстЗапроса) Экспорт 

	// Исправление имен временных таблиц
	Результат = СтрЗаменить(ТекстЗапроса, "#tt", "pg_temp.tt");
	
	Возврат Результат;
	
КонецФункции

Функция СозданиеВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы) Экспорт 
	
	Результат = НРег(ТекстЗапросаMSSQL);
	НомерСессии = СтрокаТаблицы.НомерСессии;
	ИмяТаблицы = ИмяВТ(Результат, "create table #");
	
	Результат = ИсправитьИменаВТЗапроса(Результат);
	Результат = СтрЗаменить(Результат, "create table", "CREATE TEMPORARY TABLE");
	Результат = СтрЗаменить(Результат, " collate database_default", "");
	Результат = СтрЗаменить(Результат, " int identity(1, 1)", " SERIAL");
	
	ЗаполнитьПоляВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ИмяТаблицы, Результат, ДопТаблицы);
	
	Возврат Результат;
	
КонецФункции

Функция ИмяВТ(Знач ТекстЗапроса, Знач ПодстрокаПоиска, ЕстьПодчеркивание = Ложь) Экспорт 
	
	ПодстрокаПоиска = СтрЗаменить(ПодстрокаПоиска, ".", "\.");
	Если ЕстьПодчеркивание Тогда
		РегПодстрокаПоиска = СтрШаблон("%1(tt\d+(_\d+)?)\b", ПодстрокаПоиска);
	Иначе	
		РегПодстрокаПоиска = СтрШаблон("%1(tt\d+)\b", ПодстрокаПоиска);
	КонецЕсли;
	
	Результат = СтрНайтиПоРегулярномуВыражению(ТекстЗапроса, РегПодстрокаПоиска,,,1).ПолучитьГруппы()[0].Значение;

	Возврат Результат;
	
КонецФункции

Функция СоответствиеИменТиповДанных() Экспорт 
	
	//ПОРЯДОК СТРОК ВАЖЕН, ПОЭТОМУ НЕ СООТВЕТСТВИЕ, А ТАБЛИЦА!!!
	СоответствиеИменТиповДанных = Новый ТаблицаЗначений;
	СоответствиеИменТиповДанных.Колонки.Добавить("ИмяТипаMSSQL", Новый ОписаниеТипов("Строка", ,
														 Новый КвалификаторыСтроки(100, ДопустимаяДлина.Переменная)));
	СоответствиеИменТиповДанных.Колонки.Добавить("ИмяТипаPG", Новый ОписаниеТипов("Строка", ,
														 Новый КвалификаторыСтроки(100, ДопустимаяДлина.Переменная)));
	
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "ntext";
	НоваяСтрока.ИмяТипаPG = "TEXT";
	
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "nvarchar";
	НоваяСтрока.ИмяТипаPG = "MVARCHAR";
	
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "nvarchar";
	НоваяСтрока.ИмяТипаPG = "TEXT";
	
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "varbinary";
	НоваяСтрока.ИмяТипаPG = "BYTEA";
	
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "varchar";
	НоваяСтрока.ИмяТипаPG = "TEXT";
	
	// Замена типов у которых в скобках есть цифры
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "datetime2";
	НоваяСтрока.ИмяТипаPG = "TIMESTAMP";
	
	// Все оставшиеся бинари(1) считаем булеаном
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "binary";
	НоваяСтрока.ИмяТипаPG = "BOOLEAN";
	
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "binary";
	НоваяСтрока.ИмяТипаPG = "BYTEA";
	
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "datetime";
	НоваяСтрока.ИмяТипаPG = "TIMESTAMP";
	
	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "numeric";
	НоваяСтрока.ИмяТипаPG = ВРег("numeric");

	НоваяСтрока = СоответствиеИменТиповДанных.Добавить();
	НоваяСтрока.ИмяТипаMSSQL = "nchar";
	НоваяСтрока.ИмяТипаPG = "MVARCHAR";

	Возврат СоответствиеИменТиповДанных;
	
КонецФункции

Функция ИсправитьБинари1ВТекстеПриЗаполненииВТ(НастройкаТеста, СтрокаТаблицы, Знач Результат, ДопТаблицы) Экспорт 

	// Отдельно для заполнения ВТ, когда можем ориентироваться по имени поля куда ставляется 0x01 либо если еще не заполнены параметры по типам и колонкам
		
	ЕстьValues = СтрНайти(Результат, " values(") > 0;
	ЕстьОтдельноСтроящие0x01 = Не ЕстьValues И СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01()).Длина > 0; 
	// Если остались 0x01 в case после замены в ИсправитьБинари1ВТексте, то тоже попробуем определить по плану запроса
	Есть0x01ВCase = СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина > 0;
	ИмяТаблицы = НастройкаТестов_СозданиеВременныхТаблиц.ИмяВТ(Результат, "insert into pg_temp.");
	// Если вообще нет записей по текущей ВТ в РС ПоляВременныхТаблицыPostgres, то их нужно заполнить - получается, что текущее событие заполнения ВТ и есть создание ВТ, 
	// т.к. при последующем создании ВТ с тамик же имененм (при рестарте сервера 1С) Поля будут заполнены
	ЗаполняемПоляВременнойТаблицы = Не ЗначениеЗаполнено(ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, СтрокаТаблицы.НомерСессии, ИмяТаблицы)) И ЕстьValues;
	ЕстьВValues0x01 = ЕстьValues И СтрНайтиПоРегулярномуВыражению(Результат, "(values\(|,)\s*(0x01)\s*(\)|,)").Длина > 0; 
	
	Если Есть0x01ВCase И ЗначениеЗаполнено(СтрокаТаблицы.ПланЗапроса) Тогда

		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ПланЗапроса.ЗапросИсточник) Тогда
			
			Если Не ЗначениеЗаполнено(СтрокаТаблицы.ОшибкаПреобразования) Тогда
				НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Поймали ситуацию, когда в процедуре в НастройкаТестов_СозданиеВременныхТаблиц.ИсправитьБинари1ВТекстеПриЗаполненииВТ перешли к разбору case имеющих отдельностоящие 0x01, но не заполнен СтрокаТаблицы.ПланЗапроса.ЗапросИсточник - массив подзапросов через union. Возможно недоразобрались параметры запроса rpc_completed, но нет ошибки""Ошибка разбора параметров"" или ""Ошибка получения плана запроса"". Нужна отладка");
				НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ОтладкаСозданияВТ",,ДопТаблицы.Многопоточность);
			Иначе	
				НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Пропущен разбор case имеющих отдельностоящие 0x01 в НастройкаТестов_СозданиеВременныхТаблиц.ИсправитьБинари1ВТекстеПриЗаполненииВТ");
			КонецЕсли;
			
		Иначе
		
			Для каждого ПолеИсточник Из СтрокаТаблицы.ПланЗапроса.ЗапросИсточник Цикл
				
				ТекЗапрос = ПланЗапросов.ТекстТекущегоЗапроса(Результат, СтрокаТаблицы.ПланЗапроса.ЗапросИсточник, ПолеИсточник);
				
				// Если в текущем запросе есть 0x01ВCase
				Если СтрНайтиПоРегулярномуВыражению(ТекЗапрос, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина > 0 Тогда
					
					Инд = 0;
					Для каждого ПодстрокаПоиска Из ПолеИсточник.МассивПолей Цикл
						
						Если СтрНайтиПоРегулярномуВыражению(ПодстрокаПоиска, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина > 0 Тогда
							
							// Может быть не совсем корректно: 
							//insert into pg_temp.tt889 (_q_000_f_000, _q_000_f_001rref) select
							//cast((count(distinct case when t1.q_001_f_000_type = '\\001'::BYTEA then 0x01 end) + count(distinct case when t1.q_001_f_000_type = '\\x08'::BYTEA then t1.q_001_f_000_rtref || t1.q_001_f_000_rrref end)) as NUMERIC(12)),
							//но оставляю типа если поле вт не _type, то пусть будет булево
							Если Прав(СтрокаТаблицы.ПланЗапроса.ПоляПриемника[Инд], СтрДлина("_type")) = "_type" Тогда
								ПодстрокаЗамены = СтрЗаменитьПоРегулярномуВыражению(ПодстрокаПоиска, НастройкаТестовКлиентСервер.Шаблон0x01вCase(), "$1'\\\\x01'::BYTEA");
							Иначе
								ПодстрокаЗамены = СтрЗаменитьПоРегулярномуВыражению(ПодстрокаПоиска, НастройкаТестовКлиентСервер.Шаблон0x01вCase(), "$1TRUE");
							КонецЕсли;
							
							ПолеИсточник.МассивПолей[Инд] = ПодстрокаЗамены;
							
							// Можем заменить сразу во всем запросе, т.к. явно, что такие конструкции case...end будут уникальны. Правда я не заменяю в плане запроса по остальным, но это и не важно на текущий момент
							Результат = СтрЗаменить(Результат, ПодстрокаПоиска, ПодстрокаЗамены); 
							Если СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина = 0 Тогда
								Прервать;	
							КонецЕсли;
							
						КонецЕсли;
						
						Инд = Инд + 1;
						
					КонецЦикла;
					
					Если СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина = 0 Тогда
						Прервать;	
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Ищем отдельностоящие 0x01 и определяем по имени поля ВТ, если в конце "_type", то это bytea, иначе это TRUE 	
	Если ЕстьОтдельноСтроящие0x01 И ЗначениеЗаполнено(СтрокаТаблицы.ПланЗапроса) Тогда 
		
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ПланЗапроса.ЗапросИсточник) Тогда
			
			Если Не ЗначениеЗаполнено(СтрокаТаблицы.ОшибкаПреобразования) Тогда
				НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Поймали ситуацию, когда в процедуре в НастройкаТестов_СозданиеВременныхТаблиц.ИсправитьБинари1ВТекстеПриЗаполненииВТ перешли к разбору отдельностоящих 0x01, но не заполнен СтрокаТаблицы.ПланЗапроса.ЗапросИсточник - массив подзапросов через union. Возможно недоразобрались параметры запроса rpc_completed, но нет ошибки""Ошибка разбора параметров"" или ""Ошибка получения плана запроса"". Нужна отладка");
				НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ОтладкаСозданияВТ",,ДопТаблицы.Многопоточность);
			Иначе	
				НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Пропущен разбор case имеющих отдельностоящие 0x01 в НастройкаТестов_СозданиеВременныхТаблиц.ИсправитьБинари1ВТекстеПриЗаполненииВТ");
			КонецЕсли;
			
		Иначе
			
			ПодстрокаЗапроса = "\bselect\b";
			Для каждого ПолеИсточник Из СтрокаТаблицы.ПланЗапроса.ЗапросИсточник Цикл
				
				ПозНач = СтрНайтиПоРегулярномуВыражению(Результат, ПодстрокаЗапроса,, , ПолеИсточник.НомерВыборки).НачальнаяПозиция;
				Пока Истина Цикл
					
					Инд = ПолеИсточник.МассивПолей.Найти("0x01");
					Если Инд = Неопределено Тогда
						Прервать;	
					КонецЕсли; 
					
					Если Прав(СтрокаТаблицы.ПланЗапроса.ПоляПриемника[Инд], СтрДлина("_type")) = "_type" Тогда
						ПодстрокаЗамены = "'\\x01'::BYTEA";
					Иначе
						ПодстрокаЗамены = "TRUE";
					КонецЕсли;
						
					ПолеИсточник.МассивПолей[Инд] = ПодстрокаЗамены;
					
					ПозНач = СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01(),,ПозНач).ПолучитьГруппы()[4].НачальнаяПозиция;
					
					// Т.к. подстрока с начала до найденного 0x01 уникальна в рамаках запроса (есть же value), может эту подстроку заменить на такую же подстроку с начала запроса до нужной позиции + ПодстрокаЗамены
					Результат = СтрЗаменить(Результат, Лев(Результат, ПозНач + СтрДлина("0x01") - 1), СтрШаблон("%1%2", Лев(Результат, ПозНач - 1), ПодстрокаЗамены)); 
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЕсли;
		
	ИначеЕсли ЕстьВValues0x01 И ЗначениеЗаполнено(СтрокаТаблицы.ПланЗапроса) Тогда
		
		ПозНач = СтрНайти(Результат, " values("); 
		Пока Истина Цикл
			
			Инд = СтрокаТаблицы.ПланЗапроса.Значения.Найти("0x01");
			Если Инд = Неопределено Тогда
				Прервать;	
			КонецЕсли; 
			
			Если Прав(СтрокаТаблицы.ПланЗапроса.ПоляПриемника[Инд], СтрДлина("_type")) = "_type" Тогда
				ПодстрокаЗамены = "'\\x01'::BYTEA";
			Иначе
				ПодстрокаЗамены = "TRUE";
			КонецЕсли;
				
			СтрокаТаблицы.ПланЗапроса.Значения[Инд] = ПодстрокаЗамены;
			
			ПозНач = СтрНайтиПоРегулярномуВыражению(Результат, "(values\(|,)\s*(0x01)\s*(\)|,)",,ПозНач).ПолучитьГруппы()[1].НачальнаяПозиция;
			
			// Т.к. подстрока с начала до найденного 0x01 уникальна в рамаках запроса (есть же value), может эту подстроку заменить на такую же подстроку с начала запроса до нужной позиции + ПодстрокаЗамены
			Результат = СтрЗаменить(Результат, Лев(Результат, ПозНач + СтрДлина("0x01") - 1), СтрШаблон("%1%2", Лев(Результат, ПозНач - 1), ПодстрокаЗамены)); 
			
		КонецЦикла;
		
	КонецЕсли;
			
	Если ЗаполняемПоляВременнойТаблицы Тогда
		
		Сч = 0;
		Для каждого Значение Из СтрокаТаблицы.ПланЗапроса.Значения Цикл
			
			Поз = СтрНайти(Значение, "::");
			
			Если Поз = 0 И Значение = "FALSE" ИЛИ Значение = "TRUE" Тогда
				Тип	= "BOOLEAN";
			Иначе
				Тип = Прав(Значение, СтрДлина(Значение) - Поз - 1);
			КонецЕсли;
			
			// На всякий случай, если нет типизации поля, то удаляем уже сохраненные данные
			Если Поз = 0 Тогда
				
				Строки = ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, СтрокаТаблицы.НомерСессии, ИмяТаблицы, СтрокаТаблицы.ДатаСобытия, СтрокаТаблицы.НомерСобытия);
				Для каждого Строка Из Строки Цикл
					ДопТаблицы.ПоляВременныхТаблицыPostgres.Удалить(Строка);	
				КонецЦикла;
				
				Прервать;  
				
			КонецЕсли;
			
			НоваяСтрока = ДопТаблицы.ПоляВременныхТаблицыPostgres.Добавить();
			НоваяСтрока.ВидИзменения = 1;
        	НоваяСтрока.НастройкаТеста = НастройкаТеста;
			НоваяСтрока.ИмяТаблицы = ИмяТаблицы;
			НоваяСтрока.ДатаСоздания = СтрокаТаблицы.ДатаСобытия;
			НоваяСтрока.НомерСобытия = СтрокаТаблицы.НомерСобытия;
			НоваяСтрока.НомерСессии = СтрокаТаблицы.НомерСессии;
			НоваяСтрока.Имя = СтрокаТаблицы.ПланЗапроса.ПоляПриемника[Сч];
			НоваяСтрока.Тип = Тип;
			НоваяСтрока.НомерПоля = Сч + 1;
			УстановитьИмяТипа(НоваяСтрока);

			Сч = Сч + 1;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
		
КонецФункции 

Функция ЗаполнитьПоляВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ИмяТаблицы, Результат, ДопТаблицы = Неопределено, ОбновлятьДанныеВРегистрах = Ложь, СохранятьИсправленныеВТ = Неопределено, ИсправлятьСкрипт = Истина) Экспорт 
	
	НомерСессии = СтрокаТаблицы.НомерСессии;
	НомерСобытия = СтрокаТаблицы.НомерСобытия;
	ДатаСоздания = СтрокаТаблицы.ДатаСобытия;
	
	Если ДопТаблицы <> Неопределено Тогда
		СоответствиеТиповДанных		= ДопТаблицы.СоответствиеТиповДанных;
		ВременныеТаблицыPostgres	= ДопТаблицы.ВременныеТаблицыPostgres;
	КонецЕсли; 
	
	Если Не ОбновлятьДанныеВРегистрах И ЗначениеЗаполнено(ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, НомерСессии, ИмяТаблицы, СтрокаТаблицы.ДатаСобытия, НомерСобытия)) Тогда
		
		Рез = Истина;
		
	// Если это не обновление данных и уже есть данные в ДопТаблицы.ПоляВременныхТаблицыPostgres, то ничего делать не нужно по ДопТаблицы.ПоляВременныхТаблицыPostgres
	Иначе

		// Определим типы данных
		ПозНач = СтрНайти(Результат, "(");
		ПозКон = СтрНайти(Результат, ")", , ПозНач);

		Сч = ПозНач + СтрДлина("(");
		КолОтр = 1;
		КолЗакр = 0;
		Пока Истина Цикл
			
			Если КолОтр = КолЗакр Тогда
				Прервать;	
			КонецЕсли;
			
			Если Сред(Результат, Сч, 1) = ")" Тогда
				КолЗакр = КолЗакр + 1;
			ИначеЕсли Сред(Результат, Сч, 1) = "(" Тогда
				КолОтр = КолОтр + 1;
			КонецЕсли;
			
			Сч = Сч + 1;
			
		КонецЦикла;
		
		ПозНач = ПозНач + СтрДлина("(");
		ПозКон = Сч - 1;
		
		ЗначенияВТСтрока = Сред(Результат, ПозНач, ПозКон - ПозНач);
		
		//  _c_31 numeric(5, 0), _ttc_1 binary(16), _ttc_1_0 numeric(7, 0), _ttc_2rref binary(16), sdbl_identity int identity(1, 1)
		// Заменим подстроки ", _" и "), " на разделитель ;;;
		НомерПоля = 1;
		ПодстрокаПоиска = СтрЗаменить(ЗначенияВТСтрока, ", _", ";;;_");
		ПодстрокаПоиска = СтрЗаменить(ПодстрокаПоиска, ",_", ";;;_");
		ПодстрокаПоиска = СтрЗаменить(ПодстрокаПоиска, "), ", ");;;");
		ПодстрокаПоиска = СтрЗаменить(ПодстрокаПоиска, "),", ");;;");
		ПодстрокаПоиска = СтрЗаменить(ПодстрокаПоиска, " ;;;", ";;;"); 
		
		Массив = СтрРазделить(ПодстрокаПоиска, ";;;", Ложь);
		
		Рез = Массив.Количество() > 0;
		
		// Если вызвали при исправлении, то очистим поля перед добавлением
		Если ОбновлятьДанныеВРегистрах Тогда
			
			Если ДопТаблицы <> Неопределено Тогда
				
				СтрокиТаблицы = ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, НомерСессии, ИмяТаблицы, ДатаСоздания, НомерСобытия);
				Для каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
					ДопТаблицы.ПоляВременныхТаблицыPostgres.Удалить(СтрокаТаблицы);	
				КонецЦикла;
				
			КонецЕсли;
			
			НаборЗаписей = РегистрыСведений.ПоляВременныхТаблицыPostgres.СоздатьНаборЗаписей(); 
			НаборЗаписей.Отбор.НастройкаТеста.Установить(НастройкаТеста);
			НаборЗаписей.Отбор.НомерСессии.Установить(НомерСессии);
			НаборЗаписей.Отбор.ИмяТаблицы.Установить(ИмяТаблицы);
			НаборЗаписей.Отбор.ДатаСоздания.Установить(ДатаСоздания);
			НаборЗаписей.Отбор.НомерСобытия.Установить(НомерСобытия);
			НаборЗаписей.Записать();
			
		КонецЕсли;
		
		Для каждого ПолеВт Из Массив Цикл
			
			ДанныеПоля = НастройкаТестов_СозданиеЗапросов.РазделитьПолеСТипом(ПолеВт, ?(ИсправлятьСкрипт, СоответствиеТиповДанных, Неопределено));
			Если ДопТаблицы = Неопределено Тогда
				НоваяСтрока = Новый Структура("НастройкаТеста,НомерСессии,ИмяТаблицы,ДатаСоздания,НомерСобытия,НомерПоля,Имя,Тип,ИмяТипа");	
			Иначе
				
				НоваяСтрока = ДопТаблицы.ПоляВременныхТаблицыPostgres.Добавить();
				НоваяСтрока.ВидИзменения = 1; 
				Если ИсправлятьСкрипт Тогда
					Результат = СтрЗаменить(Результат, ПолеВТ, СтрШаблон("%1 %2", ДанныеПоля[0], ДанныеПоля[1]));
				КонецЕсли;
				
			КонецЕсли;	
			
			НоваяСтрока.НастройкаТеста = НастройкаТеста;
			НоваяСтрока.ИмяТаблицы = ИмяТаблицы;
			НоваяСтрока.ДатаСоздания = ДатаСоздания;
			НоваяСтрока.НомерСобытия = НомерСобытия;
			НоваяСтрока.НомерСессии = НомерСессии;
			НоваяСтрока.Имя = ДанныеПоля[0];
			НоваяСтрока.Тип = ДанныеПоля[1];
			НоваяСтрока.НомерПоля = НомерПоля;
			УстановитьИмяТипа(НоваяСтрока);
			
			Если ПустаяСтрока(НоваяСтрока.Имя) Или ПустаяСтрока(НоваяСтрока.Тип) Тогда
				Рез = Ложь;	
			КонецЕсли;
			
			НомерПоля = НомерПоля + 1;
			
			Если ОбновлятьДанныеВРегистрах Тогда
				
				МенеджерРегистра = РегистрыСведений.ПоляВременныхТаблицыPostgres.СоздатьМенеджерЗаписи();
				ЗаполнитьЗначенияСвойств(МенеджерРегистра, НоваяСтрока);
				МенеджерРегистра.Записать();
				
			КонецЕсли;

		КонецЦикла;
		
		Результат = НастройкаТестов_СозданиеЗапросов.ИсправитьФункции(СтрокаТаблицы, Результат, ДопТаблицы);
		Если Не Рез и ДопТаблицы <> Неопределено Тогда
			
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Поймали ситуацию, когда В виде события СозданиеВременнойТаблицы ошибка. Нужно дописать код, что бы воткнуть отработать такую ситуацию - поискать данные в ВременныеТаблицыPostgres как это сделано в ПроверкаСуществованияВременнойТаблицы");
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ОтладкаСозданияВТ");

		КонецЕсли;
		
	КонецЕсли;
	
	Если ДопТаблицы <> Неопределено Или Рез Тогда
		
		ДобавитьДанныеВременнойТаблицы(НастройкаТеста, ИмяТаблицы, НомерСессии, НомерСобытия, ДатаСоздания, ВременныеТаблицыPostgres, Не Рез, ОбновлятьДанныеВРегистрах, Результат, СохранятьИсправленныеВТ);
		
	КонецЕсли;

	Возврат Рез;
	
КонецФункции

// Выполняется на вставке данных в ВТ, проверяет создана ли ранее уже ВТ, если нет, то пробует создать ее - текст запроса будет вставлен перед текущим запросом
Процедура ПроверкаСуществованияВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ТаблицаРезультатов, ДопТаблицы) Экспорт 
	
	ТекстЗапроса = СтрокаТаблицы.ТекстЗапросаPostgres;
	НомерСессии = СтрокаТаблицы.НомерСессии;
	
	СтрокаПоиска = "insert into pg_temp.";
	ИмяТаблицы = НастройкаТестов_СозданиеВременныхТаблиц.ИмяВТ(ТекстЗапроса, СтрокаПоиска);
	
	// Если временная таблица не была создана, ее нужно создать по данным из MS SQL
	СтрокиВТ = СтрокиВременныеТаблицыPostgres(ДопТаблицы.ВременныеТаблицыPostgres, НомерСессии, ИмяТаблицы);
	Если СтрокиВТ.Количество() = 0 Или СтрокиВТ[0].ДатаСоздания > СтрокаТаблицы.ДатаСобытия Тогда
		
		//Вычленяем поля временной таблицы
		ПозНач = СтрНайти(ТекстЗапроса, СтрокаПоиска) + СтрДлина(СтрокаПоиска) + СтрДлина(ИмяТаблицы) + 2;
		ПозКон = СтрНайти(ТекстЗапроса, ")",,ПозНач);
		ПоляСтрока = Сред(ТекстЗапроса, ПозНач, ПозКон - ПозНач);
		Поля = СтрРазделить(ПоляСтрока, ", ", Ложь);
		
		СоздатьВременнуюТаблицуПоДаннымРСВременныеТаблицы(НастройкаТеста, СтрокаТаблицы, ТаблицаРезультатов, ИмяТаблицы, Поля, ДопТаблицы);
		
	// Если ранее не смогли корректно заполнить скрипт создания ВТ, т.к. не было ДанныеПолейВременнойТаблицы, а сейчас они появились, то исправим скрипт создания и уберем ошибку из строки где эта ВТ была создана
	// Это может быть только в начале логов, значит в массиве СтрокиВТ только 1 элемент. Но теоретически может быть в любом месте
	ИначеЕсли СтрокиВТ.Количество() > 0 И СтрокиВТ[СтрокиВТ.ВГраница()].ОшибкаСоздания Тогда
		
		ДанныеПолейВременнойТаблицы = ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, НомерСессии, ИмяТаблицы);
		Если ДанныеПолейВременнойТаблицы.Количество() > 0 Тогда
			
			СтрокаВТ = СтрокиВТ[СтрокиВТ.ВГраница()];
			ИсправитьСозданиеВТ(НастройкаТеста, ТаблицаРезультатов, ИмяТаблицы, СтрокаВТ, ДанныеПолейВременнойТаблицы, ДопТаблицы);
			
		КонецЕсли;
		
	КонецЕсли;
    
КонецПроцедуры

// Создает временную таблицу по данным РС Временные таблицы. Ищет по имени ВТ и максимульному количеству колонок. Если данных нет, или подходит несколько строк, то делает заготовки скрипта создания ВТ
Процедура СоздатьВременнуюТаблицуПоДаннымРСВременныеТаблицы(НастройкаТеста, СтрокаТаблицы, ТаблицаРезультатов, ИмяТаблицы, Поля, ДопТаблицы, ДополнительныйСкриптСоздания = "")
	
	ЕстьСчетчикВконце = Поля[Поля.Вграница()] = "_ttc_1";
	КоличествоПолей = Поля.Количество();
	Если ЕстьСчетчикВконце Тогда
		КоличествоПолей = КоличествоПолей + 1;	
	КонецЕсли;
	НомерСессии = СтрокаТаблицы.НомерСессии;
	
	Структура = Новый Структура("table_name,col_max", ИмяТаблицы, КоличествоПолей);  
	Таблица = ДопТаблицы.ВТ.Скопировать(Структура, "table_id,col_id,col_name,data_name,data_len,precision,scale");  
	Таблица.Индексы.Добавить("table_id,col_id,col_name");
	ИдТаблиц = Таблица.Скопировать(, "table_id");
	ИдТаблиц.Свернуть("table_id");
	ИдМассив = ИдТаблиц.ВыгрузитьКолонку("table_id");
	ИдМассивИсходный = ОбщегоНазначения.СкопироватьРекурсивно(ИдМассив);
	
	// Откинет таблицы, у которых несоответствуют именя полей
	НомерПоля = 1;
	Для каждого Поле Из Поля Цикл
		
		КолвоТаблиц = ИдМассив.Количество();
		Для Сч = 0 По КолвоТаблиц - 1 Цикл
			
			Если Таблица.НайтиСтроки(Новый Структура("table_id,col_id,col_name", ИдМассив[КолвоТаблиц - 1 - Сч], НомерПоля, Поле)).Количество() = 0 Тогда
				
				ИдМассив.Удалить(КолвоТаблиц - 1 - Сч);
				
			КонецЕсли;             
			
		КонецЦикла;
		
		НомерПоля = НомерПоля + 1;
		
	КонецЦикла;
	
	// Если поймали структуру по этой ВТ выше
    ДанныеПолейВременнойТаблицы = ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, НомерСессии, ИмяТаблицы, СтрокаТаблицы.ДатаСобытия, СтрокаТаблицы.НомерСобытия);
	
	// Возможно эта проверка не нужна. ОСТАВИЛ ТОЧКУ ОСТАНОВА ЕСЛИ ХОТЬ РАЗ ПОЙМАЮ, ТО НУЖНА)
	Для каждого Строка Из ДанныеПолейВременнойТаблицы Цикл
		
		КолвоТаблиц = ИдМассив.Количество();
		Для Сч = 0 По КолвоТаблиц - 1 Цикл
			
			СтрокаТабл = Таблица.НайтиСтроки(Новый Структура("table_id,col_id,col_name", ИдМассив[КолвоТаблиц - 1 - Сч], Строка.НомерПоля, Строка.Имя))[0];
			Если ДопТаблицы.СоответствиеИменТиповДанных.НайтиСтроки(Новый Структура("ИмяТипаMSSQL,ИмяТипаPG",СтрокаТабл.data_name,ВРег(Строка.ИмяТипа))).Количество() = 0 Тогда

				ИдМассив.Удалить(КолвоТаблиц - 1 - Сч);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если ИдМассив.Количество() = 0 Тогда
		
		Текст = "";
		// Если есть данные по полям, то можем создать ВТ по ним
		Если ДанныеПолейВременнойТаблицы.Количество() > 0 Тогда
			
			Текст = ТекстСозданияВТПоДанныхПолей(ДанныеПолейВременнойТаблицы, ИмяТаблицы);

		Иначе
		    // Заготовка для создания ВТ
			Текст = СтрСоединить(Поля, " ,");
			Текст = СтрШаблон("--Заготовка под создание ВТ%1--CREATE TEMPORARY TABLE pg_temp.%2 (%3 )",Символы.ПС, ИмяТаблицы, Текст);
			Если ЗначениеЗаполнено(ДополнительныйСкриптСоздания) Тогда
				Текст = СтрШаблон("%1%2--Дополнительный скрипт %3", Текст, Символы.ПС, ДополнительныйСкриптСоздания);
			КонецЕсли;
			СтрокаТаблицы.ТекстЗапросаPostgres = СтрШаблон("%1%2;%2%3", Текст, Символы.ПС, СтрокаТаблицы.ТекстЗапросаPostgres);
		
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ОтсутствуетВТ",,ДопТаблицы.Многопоточность);
			
		КонецЕсли;
		
		ДобавитьДанныеВременнойТаблицы(НастройкаТеста, ИмяТаблицы, НомерСессии, СтрокаТаблицы.НомерСобытия, СтрокаТаблицы.ДатаСобытия, ДопТаблицы.ВременныеТаблицыPostgres, ДанныеПолейВременнойТаблицы.Количество() = 0,,Текст);

	Иначе
		
		ТабТексты = Новый ТаблицаЗначений;
		ТабТексты.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка", ,
												 Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
		// Если водходит несколько ВТ, но возможно колонки у них одинаковы и после сворачивания останется одна ВТ и ошибки не будет										 
		Для каждого Ид Из ИдМассив Цикл
			
			НоваяСтрока = ТабТексты.Добавить();
			
			СтрокиТаблицы = Таблица.НайтиСтроки(Новый Структура("table_id", Ид)); 
			
			Текст = "";
			
			Для Сч = 0 По Поля.Вграница() Цикл
				
				Стр = СтрокиТаблицы[Сч];
				
				ОграничениеТипа = "";
				
				Если ЗначениеЗаполнено(Стр.precision) Тогда
					ОграничениеТипа = СтрШаблон("%1%2", Формат(Стр.precision, "ЧГ=0"), ?(ЗначениеЗаполнено(Стр.scale), СтрШаблон(",%1", Формат(Стр.scale, "ЧГ=0")), ""));
				ИначеЕсли ЗначениеЗаполнено(Стр.data_len) Тогда
					ОграничениеТипа = Формат(Стр.data_len, "ЧГ=0");
				КонецЕсли;
				
				Тип = СтрШаблон("%1%2", Стр.data_name, ?(ЗначениеЗаполнено(ОграничениеТипа), СтрШаблон("(%1)", ОграничениеТипа), ""));
				// Бинари 1 будем исправлять сразу, остальные единомоментно в тексте
				Если Тип = "binary(1)" Тогда
					Тип = НастройкаТестов_СозданиеЗапросов.ТипБинари1(Поля[Стр.col_id - 1]);
				КонецЕсли;
				Текст = СтрШаблон("%1%2 %3, ", Текст, Поля[Стр.col_id - 1], Тип); 
				
			КонецЦикла;
			
			Текст = НастройкаТестов_СозданиеЗапросов.ИсправитьТипыДанных(ДопТаблицы.СоответствиеТиповДанных, Текст);
			
			Если ЕстьСчетчикВконце Тогда
				Текст = СтрШаблон("%1sdbl_identity SERIAL, ", Текст);	
			КонецЕсли;
			
			Текст = СтрШаблон("CREATE TEMPORARY TABLE pg_temp.%1 (%2)", ИмяТаблицы, Лев(Текст, СтрДлина(Текст) - 2));
			НоваяСтрока.Текст = Текст;
			
		КонецЦикла;
		
		ТабТексты.Свернуть("Текст");
		
		Если ТабТексты.Количество() > 1 Тогда
		
			// Если не понятно какая сессия ВТ, то в конце пройдем еще раз и определим по уже найденому соответсвию сессий в таблице ВТ и логах
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, СтрШаблон("Найдено %4 подходящих таблиц ""%1"" с %2 колонками %3. Вручную установите правильный текст запроса", ИмяТаблицы, Поля.Количество(), СтрСоединить(Поля, ", "), ИдМассив.Количество()));
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ЗадвоенныеВТ",,ДопТаблицы.Многопоточность);
			
			Текст = СтрШаблон("--ЗАДВОЕННАЯ ВТ. Нужно выбрать правильную%1--%2", Символы.ПС,СтрСоединить(ТабТексты.ВыгрузитьКолонку("Текст"), СтрШаблон("%1--", Символы.ПС)));
			Если ЗначениеЗаполнено(ДополнительныйСкриптСоздания) Тогда
				Текст = СтрШаблон("%1%2--Дополнительный скрипт %3", Текст, Символы.ПС, ДополнительныйСкриптСоздания);
			КонецЕсли;
			
			// Если есть ошибка, то добавляем текст запроса в основной текст. Он будет удален при исправлении ошибки
			СтрокаТаблицы.ТекстЗапросаPostgres = СтрШаблон("%1%2;%2%3", Текст, Символы.ПС, СтрокаТаблицы.ТекстЗапросаPostgres); 
			ДобавитьДанныеВременнойТаблицы(НастройкаТеста, ИмяТаблицы, НомерСессии, СтрокаТаблицы.НомерСобытия, СтрокаТаблицы.ДатаСобытия, ДопТаблицы.ВременныеТаблицыPostgres,ТабТексты.Количество() > 1,,Текст); 
			
		Иначе
			
	    	Текст = ТабТексты[0].Текст;
			ЗаполнитьПоляВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ИмяТаблицы, Текст, ДопТаблицы,,,Ложь);

		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ДанныеПолейВременнойТаблицы(ПоляВременныхТаблицыPostgres, НомерСессии, ИмяТаблицы, ДатаСоздания = Неопределено, НомерСобытия = Неопределено) Экспорт 
	
	Структура = Новый Структура("ИмяТаблицы,НомерСессии",ИмяТаблицы,НомерСессии);
	Если ЗначениеЗаполнено(ДатаСоздания) Тогда
		Структура.Вставить("ДатаСоздания", ДатаСоздания); 
	КонецЕсли;
	Если ЗначениеЗаполнено(НомерСобытия) Тогда
		Структура.Вставить("НомерСобытия", НомерСобытия); 
	КонецЕсли;
	Результат = ПоляВременныхТаблицыPostgres.НайтиСтроки(Структура);
	Возврат Результат;
	
КонецФункции

Процедура ДобавитьДанныеВременнойТаблицы(	НастройкаТеста, 
											ИмяТаблицы, 
											НомерСессии, 
											НомерСобытия, 
											ДатаСоздания, 
											ВременныеТаблицыPostgres = Неопределено, 
											ОшибкаСоздания = Ложь, 
											ОбновлятьДанныеВРегистрах = Ложь, 
											СкриптСоздания = "", 
											СохранятьИсправленныеВТ = Ложь) Экспорт  
	
	Если ВременныеТаблицыPostgres = Неопределено Тогда 
		
		НоваяСтрока	= Новый Структура("НастройкаТеста,НомерСессии,ИмяТаблицы,ДатаСоздания,ОшибкаСоздания,ОшибкаВыполнения,КоличествоСвязанныхСтрок,СкриптСоздания,НомерСобытия");
		
	Иначе
		
		Строки = ВременныеТаблицыPostgres.НайтиСтроки(Новый Структура("ИмяТаблицы,НомерСессии,ДатаСоздания",ИмяТаблицы,НомерСессии,ДатаСоздания));
		Если Строки.Количество() > 0 Тогда
			НоваяСтрока = Строки[0];
			НоваяСтрока.ВидИзменения = 2; 
		Иначе
			НоваяСтрока = ВременныеТаблицыPostgres.Добавить();
			НоваяСтрока.ВидИзменения = 1;
		КонецЕсли;	
	КонецЕсли;
	
	НоваяСтрока.НастройкаТеста 	= НастройкаТеста;
	НоваяСтрока.НомерСессии 	= НомерСессии;
	НоваяСтрока.НомерСобытия 	= НомерСобытия;
	НоваяСтрока.ИмяТаблицы 		= ИмяТаблицы;
	НоваяСтрока.ДатаСоздания 	= ДатаСоздания;
	НоваяСтрока.ОшибкаСоздания 	= ОшибкаСоздания; 
	НоваяСтрока.СкриптСоздания 	= СкриптСоздания; 
	НоваяСтрока.КоличествоСвязанныхСтрок = 0; 
	
	Если ОбновлятьДанныеВРегистрах Тогда
		
		МенеджерРегистра = РегистрыСведений.ВременныеТаблицыPostgres.СоздатьМенеджерЗаписи();
		ЗаполнитьЗначенияСвойств(МенеджерРегистра, НоваяСтрока);
		МенеджерРегистра.Записать();
		
		Если СохранятьИсправленныеВТ <> Неопределено И (СохранятьИсправленныеВТ Или ОбщегоНазначения.ЗначениеРеквизитаОбъекта(НастройкаТеста, "СохранятьИсправленныеВТ") = 1) Тогда
			
			МенеджерРегистра = РегистрыСведений.ИсправленныеСозданияВременныхТаблиц.СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(МенеджерРегистра, НоваяСтрока);
			МенеджерРегистра.Записать();
			
		КонецЕсли;
		
	КонецЕсли;
		
КонецПроцедуры

// ВидИзменения = 1 - Новая строка, 2 - Измененная строка (вначале нужно удалить, потом записать), 3 - удаляемая строка
Процедура СохранитьВременнуюТаблицы(НастройкаТеста, ВременнаяТаблица, ИмяРегистра, ОчишатьВременнуюТаблицу = Ложь) Экспорт 
	
	// Удалим измененные строки перед тем как будем записывать набором их
	Для ВидИзменения = 2 По 3 Цикл

		СтрокиТаблицы = ВременнаяТаблица.НайтиСтроки(Новый Структура("ВидИзменения", ВидИзменения));
		Для каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
			
			МенеджерРегистра = РегистрыСведений[ИмяРегистра].СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(МенеджерРегистра, СтрокаТаблицы);
			МенеджерРегистра.Удалить();
			
		КонецЦикла;	
	КонецЦикла;
	
	// Будем записывать набором только измененные и новые строки
	Для ВидИзменения = 1 По 2 Цикл
		
		ТаблицаРегистра = ВременнаяТаблица.Скопировать(Новый Структура("ВидИзменения", ВидИзменения));
		СохранитьРегистрНастройкиТеста(НастройкаТеста, ТаблицаРегистра, ИмяРегистра);
		
	КонецЦикла;
	
	Если ОчишатьВременнуюТаблицу Тогда
		ВременнаяТаблица.Очистить();
	Иначе
		
		СтрокиТаблицы = ВременнаяТаблица.НайтиСтроки(Новый Структура("ВидИзменения", 3));
		Для каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
			ВременнаяТаблица.Удалить(СтрокаТаблицы);
		КонецЦикла;	
		
		// Очистим колонки, для использования в следующей итерации
		ВременнаяТаблица.ЗаполнитьЗначения(0, "ВидИзменения");
		
	КонецЕсли;
	ТаблицаРегистра = Неопределено;
	
КонецПроцедуры

Процедура УстановитьИмяТипа(НоваяСтрока)
	
	НоваяСтрока.ИмяТипа	= СтрЗаменитьПоРегулярномуВыражению(НоваяСтрока.Тип, "(\w*)(\(*.*\)*)", "$1");
	
КонецПроцедуры

Функция ТекстСозданияВТПоДанныхПолей(ДанныеПолейВременнойТаблицы, ИмяТаблицы) Экспорт 
	
	Текст = "";
	
	Для каждого СтрокаТЗ Из ДанныеПолейВременнойТаблицы Цикл
		Текст = СтрШаблон("%1%2 %3, ", Текст, СтрокаТЗ.Имя, СтрокаТЗ.Тип); 
	КонецЦикла;
	
	Текст = СтрШаблон("CREATE TEMPORARY TABLE pg_temp.%1 (%2)", ИмяТаблицы, Лев(Текст, СтрДлина(Текст) - 2));

	Возврат Текст;
	
КонецФункции

Функция НаполненияВременныхТаблицPostgres(	НастройкаТеста, 
											Реквизиты = "*", 
											Отборы = "", 
											Параметры = Неопределено, 
											Порядок = "") Экспорт

	Отборы = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"%1%2 НастройкаТеста = &НастройкаТеста",
		Отборы,
		?(ПустаяСтрока(Отборы), "", " И"));
	Если Не ТипЗнч(Параметры) = Тип("Структура") Тогда
		Параметры = Новый Структура;	
	КонецЕсли;
	Параметры.Вставить("НастройкаТеста", НастройкаТеста);
	
	РезультатЗапроса = ИТМ_ОбщегоНазначенияСервер.ПолучитьРезультатЗапросаПоТаблице(
		"РегистрСведений.НаполненияВременныхТаблицPostgres",
		,,,
		Реквизиты,
		Отборы,
		Параметры,
		Порядок);

	Результат = РезультатЗапроса.Выгрузить();
	
	Возврат Результат;
	
КонецФункции

// Заполняем незафиксированные обработанные наполнения ВТ в прошлом запуске, т.е не дошли до следующей очистки ВТ, т.е сохранили их на пустой период
Функция ПрошлоеНаполнениеВТ(НастройкаТеста)
	
	Результат = НаполненияВременныхТаблицPostgres(НастройкаТеста,,"Период = ДАТАВРЕМЯ(2000,1,1)"); 
	НастройкаТестовСервер.ДобавитьКолонкиИзмененияВТаблицу(Результат);
	Результат.ЗаполнитьЗначения(2, "ВидИзменения");
	
	Возврат Результат;
	
КонецФункции

// Заполняем данные начала незафиксированных наполнений ВТ
Функция ПрошлоеНачалоТекущегоНаполненияВТ(НастройкаТеста, ТекущееНаполненияВТ)
	
	// Определяем ДатаСобытия для настроек незафиксированных ВТ - мы их специально незаписали, что оставить признак незафиксированности
	Если ЗначениеЗаполнено(ТекущееНаполненияВТ) Тогда
		
		Запрос = Новый Запрос;
		Запрос.Текст = "
		|ВЫБРАТЬ
		|	Таблица.НомерСобытияСоздания КАК НомерСобытияСоздания,   
		|	Таблица.НомерСессии КАК НомерСессии,   
		|	Таблица.ИмяТаблицы КАК ИмяТаблицы   
		|ПОМЕСТИТЬ ВТ_Таблица	   
		|ИЗ	   
		|	&Таблица КАК Таблица   
		|;
		|
		|ВЫБРАТЬ
		|	Таблица.НомерСобытияСоздания КАК НомерСобытияСоздания,   
		|	Таблица.НомерСессии КАК НомерСессии,   
		|	Таблица.ИмяТаблицы КАК ИмяТаблицы,
		|   РС.ДатаСобытия КАК Период
		|ИЗ
		|  	ВТ_Таблица КАК Таблица
		|ЛЕВОЕ СОЕДИНЕНИЕ
		|	РегистрСведений.РезультатыВыполненияЗапросов КАК РС 
		|ПО
		|	Таблица.НомерСобытияСоздания = РС.НомерСобытия 
		|	И Таблица.НомерСессии = РС.НомерСессии 
		|ГДЕ	
		|	РС.НастройкаТеста = &НастройкаТеста	
		|	
		|";
		
		Запрос.УстановитьПараметр("Таблица", ТекущееНаполненияВТ);
		Запрос.УстановитьПараметр("НастройкаТеста", НастройкаТеста);
		РезультатЗапроса = Запрос.Выполнить();
		Результат = РезультатЗапроса.Выгрузить();
		
	Иначе
		
		Результат = НастройкаТестовСервер.ПустаяТаблицаРегистраСведений("НаполненияВременныхТаблицPostgres", "НомерСессии,ИмяТаблицы,НомерСобытияСоздания,Период"); // Данные по текущим наполнениям ВТ, где Ключ
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции



Процедура УстановитьПризнакПропущеноНаполениеВТ(НастройкаТеста, СтрокиТекНаполнения, ДопТаблицы)
	
	Для каждого СтрокаНаполнения Из СтрокиТекНаполнения Цикл 
		
		СтруктураПоиска = Новый Структура("НомерСессии,НомерСобытия");
		ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаНаполнения);
		СтрокиРезультата = ДопТаблицы.ТаблицаРезультатов.НайтиСтроки(СтруктураПоиска);
		
		Если ЗначениеЗаполнено(СтрокиРезультата) Тогда
			
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокиРезультата[0], "ПропущеноНаполнениеВТ",,ДопТаблицы.Многопоточность);
			
		Иначе
			
			ТекстОшибки = СтрШаблон("При обработке предыдущих наполнений ВТ %1 в сессии %2 в таблице РезультатыВыполненияЗапросов не найдена строка с номером события %3. ОНа нужна для установки ошибки преобразования. 
				|Если эта строка есть в РС, то необходимо дописать код, что бы ее искать в РС и заносить в таблицу РезультатыВыполненияЗапросов, выставлять признак измененная и выставлять ошибку преобразования.", 
				СтрокаНаполнения.ИмяТаблицы, 
				СтрокаНаполнения.НомерСессии, 
				СтрокаНаполнения.НомерСобытия);
			НастройкаТестовСервер.ЗаписатьОшибкуВЖР(НастройкаТеста, ТекстОшибки, "НаполненияВременныхТаблицPostgres", ДопТаблицы);
			
		КонецЕсли;
		
		ДопТаблицы.ТекущееНаполненияВТ.Удалить(СтрокаНаполнения);
		
	КонецЦикла;

		
КонецПроцедуры

Функция ИсправлениеОпределениеПодготовленногоОператораВТ(НастройкаТеста, ТаблицаРезультатов, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы) Экспорт 
	
	ПозНач = СтрНайти(ТекстЗапросаMSSQL, ",n'",,,2);
	ПозКон = СтрНайти(ТекстЗапросаMSSQL, "',",НаправлениеПоиска.СКонца);
	
	ТекстЗапроса = Сред(ТекстЗапросаMSSQL, ПозНач + 3, ПозКон - ПозНач - 3);
	ТекстЗапроса = ИсправитьИменаВТЗапроса(ТекстЗапроса);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "@p", "$");

	ИмяТаблицы = ИмяВТ(ТекстЗапроса, "insert into pg_temp.");
	ИмяОператора = НастройкаТестовСервер.ИмяПодготовленногоОператора(СтрокаТаблицы);	
	
	СтрокиВТ = СтрокиВременныеТаблицыPostgres(ДопТаблицы.ВременныеТаблицыPostgres, СтрокаТаблицы.НомерСессии,ИмяТаблицы);
	Если СтрокиВТ.Количество() = 0 Или СтрокиВТ[0].ДатаСоздания > СтрокаТаблицы.ДатаСобытия Тогда
		ДатаСоздания = СтрокаТаблицы.ДатаСобытия;	
		НомерСобытия = СтрокаТаблицы.НомерСобытия;	
	ИначеЕсли СтрокиВТ.Количество() = 1 Тогда
		ДатаСоздания = СтрокиВТ[СтрокиВТ.ВГраница()].ДатаСоздания;
		НомерСобытия = СтрокиВТ[СтрокиВТ.ВГраница()].НомерСобытия;
	Иначе
		// Ищем подходящую строку для создания скрипта ВТ
		СтрокаСозданияСкрипта = Неопределено;
		Для каждого Строка Из СтрокиВТ Цикл
			
			Если Строка.ДатаСоздания = СтрокаТаблицы.ДатаСобытия И Строка.НомерСобытия = СтрокаТаблицы.НомерСобытия Тогда
				СтрокаСозданияСкрипта = Строка;
				Прервать;
			ИначеЕсли Строка.ДатаСоздания > СтрокаТаблицы.ДатаСобытия Тогда
				Если СтрокаСозданияСкрипта = Неопределено Тогда
					СтрокаСозданияСкрипта = Строка;
				КонецЕсли;
				Прервать;	
			КонецЕсли;	
			
			СтрокаСозданияСкрипта = Строка;
						
		КонецЦикла;
		
		ДатаСоздания = СтрокаСозданияСкрипта.ДатаСоздания;
		НомерСобытия = СтрокаСозданияСкрипта.НомерСобытия; 
		
	КонецЕсли;
	
	// Если это первый вызов ВТ или не смогли определить ее поля, то заполним ее поля
	Если СтрокиВТ.Количество() = 0 Или СтрокиВТ[0].ДатаСоздания > СтрокаТаблицы.ДатаСобытия Тогда
		
		ПозНачПарам = СтрНайти(ТекстЗапросаMSSQL, ",n'");
		ТекстПараметров = Сред(ТекстЗапросаMSSQL, ПозНачПарам + 3, ПозНач - ПозНачПарам - 4);
		ТекстПараметров = СтрЗаменитьПоРегулярномуВыражению(ТекстПараметров, "@p\d+\s+", "");
		
		// Не получается просто разложить в массив по запятой, т.к. в типах может быть запятая
		// NUMERIC(38,9),varbinary(16),varbinary(16),nvarchar(max),nvarchar(max),varbinary(1)
		КолОткр = 0;
		ТипыПараметров = Новый Массив;
		СчНач = 1;
		Для Сч = 1 По СтрДлина(ТекстПараметров) Цикл
			Символ = Сред(ТекстПараметров, Сч, 1);
			Если Символ = "(" Тогда
				КолОткр = КолОткр + 1;
			ИначеЕсли Символ = ")" Тогда
				КолОткр = КолОткр - 1;
			ИначеЕсли Символ = "," И КолОткр = 0 Тогда
				ТипыПараметров.Добавить(Сред(ТекстПараметров, СчНач, Сч - СчНач));
				СчНач = Сч + 1;
			КонецЕсли;
		КонецЦикла;            
		ТипыПараметров.Добавить(Сред(ТекстПараметров, СчНач, Сч - СчНач));		
		// Определеим поля для преобразования binary(1)
		ПозНач = СтрНайти(ТекстЗапроса, "(");
		ПозКон = СтрНайти(ТекстЗапроса, ")");
		ТекстПолей = Сред(ТекстЗапроса, ПозНач + 1, ПозКон - ПозНач - 1);
		Поля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТекстПолей, ",", Истина);
		
		// Определим текст запроса создания ВТ по данным текущего Определения ПО, но это не будет основной текст
		// Основным будет поиск по РС Временные таблицы, по текущим данным сделаем дополнительный скрипт
		ДанныеПолейВременнойТаблицы = Новый Массив;
		Для Сч = 0 По Поля.Вграница() Цикл
			
			Тип = ТипыПараметров[Сч];
			
			Если Тип = "binary(1)" Тогда
				Тип = НастройкаТестов_СозданиеЗапросов.ТипБинари1(Поля[Сч]);
			Иначе
				Тип = НастройкаТестов_СозданиеЗапросов.ИсправитьТипыДанных(ДопТаблицы.СоответствиеТиповДанных, Тип, Истина);
			КонецЕсли;
			
			НоваяСтрока = Новый Структура;
			НоваяСтрока.Вставить("ВидИзменения", 1);
        	НоваяСтрока.Вставить("НастройкаТеста", НастройкаТеста);
			НоваяСтрока.Вставить("ИмяТаблицы", ИмяТаблицы);
			НоваяСтрока.Вставить("ДатаСоздания", СтрокаТаблицы.ДатаСобытия);
			НоваяСтрока.Вставить("НомерСобытия", СтрокаТаблицы.НомерСобытия);
			НоваяСтрока.Вставить("НомерСессии", СтрокаТаблицы.НомерСессии);
			НоваяСтрока.Вставить("Имя", Поля[Сч]);
			НоваяСтрока.Вставить("Тип", Тип);
			НоваяСтрока.Вставить("НомерПоля", Сч + 1);
			НоваяСтрока.Вставить("ИмяТипа");
			УстановитьИмяТипа(НоваяСтрока);
			
			ДанныеПолейВременнойТаблицы.Добавить(НоваяСтрока);
			
		КонецЦикла; 
		
		ДополнительныйСкриптСоздания = ТекстСозданияВТПоДанныхПолей(ДанныеПолейВременнойТаблицы, ИмяТаблицы);
		
		СоздатьВременнуюТаблицуПоДаннымРСВременныеТаблицы(НастройкаТеста, СтрокаТаблицы, ТаблицаРезультатов, ИмяТаблицы, Поля, ДопТаблицы, ДополнительныйСкриптСоздания);
		
	КонецЕсли;
		
	// Выберем данные по полям из последней ВТ
	ДанныеПолейВременнойТаблицы = ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, СтрокаТаблицы.НомерСессии, ИмяТаблицы, ДатаСоздания,НомерСобытия);
	
	// Если каким то образом не заполнили, то пока ошибка
	Если Не ЗначениеЗаполнено(ДанныеПолейВременнойТаблицы) Тогда
		НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Поймали ситуацию, когда не смогли получить скрипт создания ВТ по данным РС ВременныеТаблицы. Нужна отладка");
		НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ОтладкаПодготовленныхОператоров",,ДопТаблицы.Многопоточность); 
		Возврат "";
	КонецЕсли;
	
	Типы = "";
	Для каждого СтрокаДанных Из ДанныеПолейВременнойТаблицы Цикл
		Типы = СтрШаблон("%1%2%3", Типы, ?(ПустаяСтрока(Типы), "", ","), СтрокаДанных.Тип);
	КонецЦикла;
	
	// Дополним текст запроса
	ТекстЗапроса = СтрШаблон("PREPARE %1(%2) AS%3%4", ИмяОператора, Типы, Символы.ПС, ТекстЗапроса);
	
	// Запишем данные в ТЗ КолонкиВТПодготовленныхОператоров - для ускорения поиска при Вызове подготовленного оператора
	// тут будет мало записей - только те ПО, которые были созданы, но еще не разрушены
	Для каждого Строка Из ДанныеПолейВременнойТаблицы Цикл
		
		НоваяСтрока = ДопТаблицы.КолонкиВТПодготовленныхОператоров.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		НоваяСтрока.ИмяОператора = ИмяОператора;
		НоваяСтрока.ВидИзменения = 1;
		
	КонецЦикла;
	
	НоваяСтрока = ДопТаблицы.ИменаВТПодготовленныхОператоров.Добавить();
	НоваяСтрока.НомерСессии 	= СтрокаТаблицы.НомерСессии;
	НоваяСтрока.ИмяОператора 	= ИмяОператора;
	НоваяСтрока.ИмяТаблицы 		= ИмяТаблицы;
	НоваяСтрока.ДатаСоздания 	= ДатаСоздания;
	НоваяСтрока.НомерСобытия 	= НомерСобытия;
	НоваяСтрока.ВидИзменения 	= 1;
	
	Возврат ТекстЗапроса;
	
КонецФункции

Функция ИсправлениеВызовПодготовленногоОператораВТ(НастройкаТеста, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы) Экспорт
	
	ИмяОператора = НастройкаТестовСервер.ИмяПодготовленногоОператора(СтрокаТаблицы);
	ДанныеТаблицы = ДанныеТаблицыПодготовленногоОператора(ИмяОператора, СтрокаТаблицы, ДопТаблицы);
	ТекстЗапроса = "";
	
	Если ДанныеТаблицы = Неопределено Тогда
		
		НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ОтсутствуетОпределениеПодготовленногоОператора",,ДопТаблицы.Многопоточность);
		
	ИначеЕсли ЗначениеЗаполнено(ДанныеТаблицы.ИмяТаблицы) Тогда
		
		ДанныеПолейВременнойТаблицы = ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, СтрокаТаблицы.НомерСессии, ДанныеТаблицы.ИмяТаблицы, ДанныеТаблицы.ДатаСоздания,ДанныеТаблицы.НомерСобытия) ;

		ТекстПараметры = Прав(ТекстЗапросаMSSQL, СтрДлина(ТекстЗапросаMSSQL) - СтрДлина("exec sp_execute ") - СтрДлина(ИмяОператора) + 1);
		
		// Общие замены
		ТекстПараметры = СтрЗаменитьПоРегулярномуВыражению(ТекстПараметры, "'4(\d{3}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}')", "'2$1", Ложь, Ложь);// '4023-11-26 00:00:00'::TIMESTAMP - исправление первой цифры с 4 на 2
		
		НастройкаТестов_СозданиеЗапросов.МассивСтроковыхПараметров(СтрокаТаблицы, ТекстПараметры);
		ПланЗапросов.ЗаменитьСтроковыеЗначенияНаПараметры(ТекстПараметры, СтрокаТаблицы.СтроковыеПараметры, "##str##", "n");
		
		ТекстПараметры = НастройкаТестов_СозданиеЗапросов.ИсправитьБинарнойСтрокиНаBytea(ТекстПараметры);
		
		ЗначенияПараметров = СтрРазделить(ТекстПараметры, ",", Ложь);
		
		Если ЗначенияПараметров.Количество() <> ДанныеПолейВременнойТаблицы.Количество() Тогда
			
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Поймали ситуацию, когда В модуле НастройкаТестов_СозданиеВременныхТаблиц.ИсправлениеВызовПодготовленногоОператораВТ некорректно выполнен разбор параметров - несоответсвие количеств. Нужна отладка");
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ОтладкаПодготовленныхОператоров",,ДопТаблицы.Многопоточность);
			
			Возврат ТекстЗапроса;
				
		КонецЕсли;
		
		ТекстПараметры = "";
		
		Для Сч = 0 По ЗначенияПараметров.ВГраница() Цикл
			
			Если ЗначенияПараметров[Сч] = "0x01" Тогда 
				
				Если ДанныеПолейВременнойТаблицы[Сч].Тип = "BOOLEAN" Тогда
					ЗначениеПараметра = "TRUE";
				Иначе 
					ЗначениеПараметра = "'\\x01'::BYTEA";
				КонецЕсли;
				
			ИначеЕсли ЗначенияПараметров[Сч] = "FALSE" Или СтрНайти(ЗначенияПараметров[Сч], "::") > 0 Тогда
				
				ЗначениеПараметра = ЗначенияПараметров[Сч];
				
			Иначе
				
				ЗначениеПараметра = СтрШаблон("%1::%2", ЗначенияПараметров[Сч], ДанныеПолейВременнойТаблицы[Сч].Тип);
				
			КонецЕсли;
			
			ТекстПараметры = СтрШаблон("%1%2%3", ТекстПараметры, ?(ПустаяСтрока(ТекстПараметры), "", ","), ЗначениеПараметра);
			
		КонецЦикла;
		
		ПланЗапросов.ЗаменитьПараметрыНаСтроковыеЗначения(ТекстПараметры, СтрокаТаблицы.СтроковыеПараметры, "##str##"); // Возвращаем на место строковые параметры
		
		ТекстЗапроса = СтрШаблон("EXECUTE %1(%2)", ИмяОператора, ТекстПараметры);
		
	КонецЕсли;

	Возврат ТекстЗапроса;
	
КонецФункции

Функция ИсправлениеРазрушениеПодготовленногоОператораВТ(НастройкаТеста, СтрокаТаблицы, ДопТаблицы) Экспорт 
	
	ИмяОператора = НастройкаТестовСервер.ИмяПодготовленногоОператора(СтрокаТаблицы);
	ДанныеТаблицы = ДанныеТаблицыПодготовленногоОператора(ИмяОператора, СтрокаТаблицы, ДопТаблицы);
	
	Если ДанныеТаблицы = Неопределено Тогда
		
		НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "ОтсутствуетОпределениеПодготовленногоОператора",,ДопТаблицы.Многопоточность);
		ТекстЗапроса = "";
		
	Иначе	
		
		// Удаление строк из ИменаВТПодготовленныхОператоров
		Строки = СтрокиКолонокВТПодготовленныхОператоров(ИмяОператора, СтрокаТаблицы.НомерСессии, ДопТаблицы.ИменаВТПодготовленныхОператоров); 
		ОбработатьСтрокиТаблицыПриРазрушенииОП(ДопТаблицы, "ИменаВТПодготовленныхОператоров", Строки);
		
		// Удаление строк из КолонкиВТПодготовленныхОператоров
		Строки = СтрокиИменВТПодготовленныйОператоров(ИмяОператора, СтрокаТаблицы.НомерСессии, ДопТаблицы.КолонкиВТПодготовленныхОператоров);
		ОбработатьСтрокиТаблицыПриРазрушенииОП(ДопТаблицы, "КолонкиВТПодготовленныхОператоров", Строки);
		
		ТекстЗапроса = СтрШаблон("DEALLOCATE %1", ИмяОператора);
	
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

Процедура ОбработатьСтрокиТаблицыПриРазрушенииОП(ДопТаблицы, ИмяТЗ, Строки)
	
	Если Строки[0].ВидИзменения = 1 Тогда
		Для каждого Строка Из Строки Цикл
			ДопТаблицы[ИмяТЗ].Удалить(Строка);
		КонецЦикла;
	Иначе	
		Для каждого Строка Из Строки Цикл
			Строка.ВидИзменения = 3;
		КонецЦикла;
 	КонецЕсли;
		
КонецПроцедуры

Функция СтрокиВременныеТаблицыPostgres(ВременныеТаблицыPostgres, НомерСессии, ИмяТаблицы) Экспорт 
	
	Результат = ВременныеТаблицыPostgres.НайтиСтроки(Новый Структура("НомерСессии, ИмяТаблицы", НомерСессии, ИмяТаблицы));
	Возврат Результат;
	
КонецФункции

// Возвращает структуру с Именем ВТ и датой создания по Имени оператора опеределенного выше, но теоретически его может не быть в начале логов
Функция ДанныеТаблицыПодготовленногоОператора(ИмяОператора, СтрокаТаблицы, ДопТаблицы)

	Строки = ДопТаблицы.ИменаВТПодготовленныхОператоров.НайтиСтроки(Новый Структура("ИмяОператора,НомерСессии", ИмяОператора, СтрокаТаблицы.НомерСессии));
	Если Строки.Количество() = 0 Тогда
		Результат = Неопределено;
		НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "СвязанныйЗапрос",,ДопТаблицы.Многопоточность);
		СтрокаТаблицы.ТекстОшибки = СтрНайти("Не найдено Имя ВТ подготовленного оператора %1", ИмяОператора);
	Иначе
		Результат = Новый Структура("ИмяОператора,ИмяТаблицы,ДатаСоздания,НомерСобытия");
		ЗаполнитьЗначенияСвойств(Результат, Строки[0]);
	КонецЕсли;                                        
	
	Возврат Результат;
	
КонецФункции 

Функция СтрокиКолонокВТПодготовленныхОператоров(ИмяОператора, НомерСессии, КолонкиВТПодготовленныхОператоров)

	Строки = КолонкиВТПодготовленныхОператоров.НайтиСтроки(Новый Структура("ИмяОператора,НомерСессии",ИмяОператора,НомерСессии));
	Возврат Строки;
	
КонецФункции

Функция СтрокиИменВТПодготовленныйОператоров(ИмяОператора, НомерСессии, ИменаВТПодготовленныхОператоров)

	Строки = ИменаВТПодготовленныхОператоров.НайтиСтроки(Новый Структура("ИмяОператора,НомерСессии",ИмяОператора,НомерСессии));
	Возврат Строки;
	
КонецФункции

// Если заполнили данные по полям ВТ, но в ВременныеТаблицыPostgres уже есть ошибочная запись про эту ВТ, то нужно исправить там ошибку
// и изменить ДатуСоздания в ПоляВременныхТаблицыPostgres
Процедура ИсправитьСозданиеВТ(НастройкаТеста, ТаблицаРезультатов, ИмяТаблицы, СтрокаВТ, ДанныеПолейВременнойТаблицы, ДопТаблицы)
	
	СтрокаВТНовая = СтрокаВТ.ВидИзменения = 1;
	
	// Получим запись РезультатыВыполненияЗапросов когда пытались создать ВТ с ошибкой
	Записи = ТаблицаРезультатов.НайтиСтроки(Новый Структура("НомерСессии,НомерСобытия",СтрокаВТ.НомерСессии, СтрокаВТ.НомерСобытия));
	Если Записи.Количество() = 0 Тогда
		ДанныеЗаписи = НастройкаТестовСервер.ДанныеИзРезультатовВыполненияЗапросов(НастройкаТеста, СтрокаВТ.ДатаСоздания, СтрокаВТ.НомерСессии, СтрокаВТ.НомерСобытия, 1);
		ОшибочнаяЗапись = ТаблицаРезультатов.Добавить();
		ЗаполнитьЗначенияСвойств(ОшибочнаяЗапись, ДанныеЗаписи);
	Иначе
		ОшибочнаяЗапись = Записи[0];
	КонецЕсли;
	
 	РеквизитыОшибки = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ОшибочнаяЗапись.ОшибкаПреобразования, "ОтсутствуетВТ,ЗадвоенныеВТ");
	
	Если НЕ ДанныеПолейВременнойТаблицы[0].ВидИзменения = 1 Тогда
		// Откоректируем ДатаСоздания в РС ПоляВременныхТаблицыPostgres - удалим по старым датам создания и запишем по корректным - по дате события когда она первых раз использовалась
		НаборЗаписей = РегистрыСведений.ПоляВременныхТаблицыPostgres.СоздатьНаборЗаписей(); 
		НаборЗаписей.Отбор.НастройкаТеста.Установить(НастройкаТеста);
		НаборЗаписей.Отбор.НомерСессии.Установить(СтрокаВТ.НомерСессии);
		НаборЗаписей.Отбор.ИмяТаблицы.Установить(ИмяТаблицы);
		НаборЗаписей.Отбор.ДатаСоздания.Установить(ДанныеПолейВременнойТаблицы[0].ДатаСоздания);
		НаборЗаписей.Отбор.НомерСобытия.Установить(ДанныеПолейВременнойТаблицы[0].НомерСобытия);
		НаборЗаписей.Записать(); 
		Для каждого Строка Из ДанныеПолейВременнойТаблицы Цикл
			Строка.ВидИзменения = 1;
		КонецЦикла;
	КонецЕсли;
	Для каждого Строка Из ДанныеПолейВременнойТаблицы Цикл
		Строка.ДатаСоздания = ОшибочнаяЗапись.ДатаСобытия;
		Строка.НомерСобытия = ОшибочнаяЗапись.НомерСобытия;
	КонецЦикла;
	
	Текст = ТекстСозданияВТПоДанныхПолей(ДанныеПолейВременнойТаблицы, ИмяТаблицы);
	ДобавитьДанныеВременнойТаблицы(НастройкаТеста, ИмяТаблицы, СтрокаВТ.НомерСессии, ОшибочнаяЗапись.НомерСобытия, ОшибочнаяЗапись.ДатаСобытия, ДопТаблицы.ВременныеТаблицыPostgres, Ложь,,Текст);
	Если СтрокаВТНовая Тогда
		СтрокаВТ.ВидИзменения = 1;
	КонецЕсли;
	
	// Убираем ошибку
	НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, ОшибочнаяЗапись, ,?(РеквизитыОшибки.ОтсутствуетВТ, "ОтсутствуетВТ", "ЗадвоенныеВТ"),ДопТаблицы.Многопоточность);
	
	// Удалим заготовки под создания ВТ
	Поз = СтрНайти(ОшибочнаяЗапись.ТекстЗапросаPostgres, "insert into pg_temp.");
	ОшибочнаяЗапись.ТекстЗапросаPostgres = Прав(ОшибочнаяЗапись.ТекстЗапросаPostgres, СтрДлина(ОшибочнаяЗапись.ТекстЗапросаPostgres) - Поз + 1 );
 		
КонецПроцедуры

Процедура СохранитьРегистрНастройкиТеста(НастройкаТеста, ТаблицаРегистра, ИмяРегистра)

	НаборЗаписей = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
	НаборЗаписей.Загрузить(ТаблицаРегистра);
	НаборЗаписей.Отбор.НастройкаТеста.Установить(НастройкаТеста);
	НаборЗаписей.Записать(Ложь);
		
КонецПроцедуры

#КонецОбласти

