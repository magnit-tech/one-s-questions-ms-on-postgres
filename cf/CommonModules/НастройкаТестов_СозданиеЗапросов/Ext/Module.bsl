#Область ПрограммныйИнтерфейс

Процедура СозданиеЗапросовФон(Параметры, АдресХранилища) Экспорт 

	Результат = СозданиеЗапросов(Параметры.НастройкаТеста, Параметры.ОчиститьЭтап, Параметры.ПараметрыТеста);
	ПоместитьВоВременноеХранилище(Результат, АдресХранилища);

КонецПроцедуры

Функция СозданиеЗапросов(НастройкаТеста, ОчиститьЭтап, ПараметрыТеста = Неопределено) Экспорт 

	ДатаНачалаОбщая = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Результат = НастройкаТестовСервер.РезультатВыполненияФоновогоЗаданияЭтапа();
	Если ПараметрыТеста = Неопределено Тогда
		ПараметрыТеста = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(НастройкаТеста, "ИнтервалОбработкиДанных");
	КонецЕсли;
	
	Попытка
		
		Если Не ОчиститьЭтап Тогда
			ЭтапОбработки = НастройкаТестовСервер.ЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.СозданиеТекстовЗапросов);
			ОчиститьЭтап = ЭтапОбработки.НомерИтерации = 0;
		КонецЕсли;
		
		Если ОчиститьЭтап Тогда                                                                                                  
			НастройкаТестовСервер.ОчиститьЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.СозданиеТекстовЗапросов);
			НастройкаТестовСервер.ОчиститьЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.ВыполнениеЗапросов);
		КонецЕсли;
		
		Многопоточность = НастройкаТестовСервер.Многопоточность();
		
		// Подготовим вспомогательные таблицы
		ДопТаблицы = Новый Структура;
		ДопТаблицы.Вставить("Многопоточность", 			Многопоточность);
		ДопТаблицы.Вставить("СоответствиеТиповДанных", 	НастройкаТестов_СозданиеЗапросов.ЗаполнитьСоответствиеТиповДанных());
		ДопТаблицы.Вставить("ОшибкиПреобразования", 	НастройкаТестов_СозданиеЗапросов.ОшибкиПреобразования());
		
		// Если рассчет не многопотоковый, то можно получить сразу все вспомогательные таблицы, которые зависят от сессий и наполняются при рассчетах
		Если Не Многопоточность Тогда
			ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы);
		КонецЕсли;

		ИсключитьВидОшибок = Новый Массив;
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ОшибкаMSSQL);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ПропущенныйЗапросMsSQL);
		ИсключитьВидОшибок.Добавить(Перечисления.ВидыОшибокЗапросов.ПропускатьПриПреобразовании);
		
		ИсключитьВидыСобытий = Новый Массив;
		ИсключитьВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.СозданиеВременнойТаблицы);
		ИсключитьВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы);
		ИсключитьВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.ОчисткаВременнойТаблицы);
		ИсключитьВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.СозданиеИндексаВременнойТаблицы);
		ИсключитьВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.ОпределениеПодготовленногоОператораВТ);
		ИсключитьВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.ВызовПодготовленногоОператораВТ);
		ИсключитьВидыСобытий.Добавить(Перечисления.ВидыСобытийЗапросов.РазрушениеПодготовленногоОператораВТ);
		
		// Отдельная структура под отборы для получения данных из РС Результаты...
		Отборы = НастройкаТестовСервер.ОтборыТаблицыРезультатов();
		Отборы.ПараметрыТеста 		= ПараметрыТеста;
		Отборы.ИсключитьВидОшибок 	= ИсключитьВидОшибок;
		Отборы.ИсключитьВидыСобытий	= ИсключитьВидыСобытий;
		ДопТаблицы.Вставить("Отборы", Отборы);

		НастройкаТестовСервер.РасчетИтераций(НастройкаТеста, ДопТаблицы);
		
		Пока Истина Цикл
			
			ДатаНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
			ДопТаблицы.Вставить("ДатаНачала", ДатаНачала);
			ЭтапОбработки = НастройкаТестовСервер.ЭтапОбработки(НастройкаТеста, Перечисления.ВидыЭтаповОбработки.СозданиеТекстовЗапросов, ДопТаблицы.НастройкиИтераций);
			ДопТаблицы.Вставить("ЭтапОбработки", ЭтапОбработки);

			Если ПараметрыТеста.ИнтервалОбработкиДанных = 0 Тогда 
				ЗаголовокСообщения = "Создание текстов запросов Postgres";
				ТекстСообещения = "Всех записей...";
			Иначе
				ЗаголовокСообщения = СтрШаблон("Создание текстов запросов. Итерация %1 из %2", ЭтапОбработки.НомерИтерации, ДопТаблицы.НастройкиИтераций.Итераций);
				ТекстСообещения = СтрШаблон("Обработка записей за %1 мин. с %2", ПараметрыТеста.ИнтервалОбработкиДанных, Формат(ЭтапОбработки.ТекущаяДатаСобытия, "ДЛФ=DT"));
			КонецЕсли;
			
			ДопТаблицы.Вставить("ЗаголовокСообщения", 	ЗаголовокСообщения);
			ДопТаблицы.Вставить("ТекстСообещения", 		ТекстСообещения);
			ДопТаблицы.Вставить("Метод", 				"НастройкаТестов_СозданиеЗапросов.ВыполнитьОдинПоток");
			ДопТаблицы.Вставить("ПредставлениеЭтапа", 	"Создание Запросов");
			ДопТаблицы.Вставить("ПодразделЖР", 			"СозданиеЗапросов");
			
			// Подготовка к многопоточности
			Если Многопоточность Тогда
				МассивЗаданий = НастройкаТестовСервер.СоздатьЗапуститьПотоки(НастройкаТеста, Результат, ДопТаблицы);
				Если Результат.ОшибкаВыполнения Тогда
					Прервать;	
				КонецЕсли;
				ДопТаблицы.Вставить("МассивЗаданий", МассивЗаданий);
			КонецЕсли;
			
			НастройкаТестовСервер.ВыполнитьИтерациюЭтапа(НастройкаТеста, ДопТаблицы, Результат);
			
			Если Результат.ОшибкаВыполнения Или ДопТаблицы.ЭтапОбработки.Завершен Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЦикла;	
		
		Если Не Результат.ОшибкаВыполнения Тогда
			НастройкаТестовСервер.СообщитьДлительностьОперации(НастройкаТеста,ДопТаблицы.ПредставлениеЭтапа, ДатаНачалаОбщая);
		   	СообщитьОбОшибкахОтладки(НастройкаТеста, "ОтладкаСозданияЗапросов"); 
			Результат.Вставить("ЭтапЗавершен", Истина);
		КонецЕсли;
		
	Исключение
		
		НастройкаТестовСервер.СообщитьОшибку(НастройкаТеста, "СозданиеТекстовЗапросов", ИнформацияОбОшибке(), Результат);
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Процедура СозданиеЗапросовПоОтборамФон(Параметры, АдресХранилища) Экспорт 

	Результат = СозданиеЗапросовПоОтборам(Параметры.НастройкаТеста, Параметры);
	ПоместитьВоВременноеХранилище(Результат, АдресХранилища);

КонецПроцедуры

Функция СозданиеЗапросовПоОтборам(НастройкаТеста, Параметры) Экспорт 
	
	ДатаНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Попытка
		
		Если Параметры.Свойство("Настройки") Тогда
			ТаблицаРезультатов = ТаблицаРезультатовПоОтбору(Параметры.Настройки);
			ПредставлениеОперации = "Создание запросов по выставленному отбору";
			ПодразделЖР = "ОбработкаСтрокПоОтбору";
		ИначеЕсли Параметры.Свойство("ВыделенныеСтроки") Тогда	
			ТаблицаРезультатов = ТаблицаРезультатовПоВыделеннымСтрокам(Параметры.ВыделенныеСтроки);
			ПредставлениеОперации = "Создание запросов по выделенным строкам"; 
			ПодразделЖР = "ОбработкаВыделенныхСтрок";
		КонецЕсли;
		Результат = НастройкаТестовСервер.РезультатВыполненияФоновогоЗаданияЭтапа();
		
		Если ЗначениеЗаполнено(ТаблицаРезультатов) Тогда
		
			ДлительныеОперации.СообщитьПрогресс(, "Подготовка вспомогательных таблиц");
		
			// Подготовим вспомогательные таблицы
			ДопТаблицы = Новый Структура;
			ДопТаблицы.Вставить("Многопоточность", Ложь);
			ДопТаблицы.Вставить("ВременныеТаблицыPostgres", НастройкаТестов_СозданиеВременныхТаблиц.ВременныеТаблицыPostgres(НастройкаТеста));
			ДопТаблицы.ВременныеТаблицыPostgres.Индексы.Добавить("НомерСессии,ИмяТаблицы");
			ДопТаблицы.ВременныеТаблицыPostgres.Индексы.Добавить("НомерСессии,ИмяТаблицы,НомерСобытия,ДатаСоздания");
			
			ДопТаблицы.Вставить("СоответствиеТиповДанных", 				НастройкаТестов_СозданиеЗапросов.ЗаполнитьСоответствиеТиповДанных());
			ДопТаблицы.Вставить("ОшибкиПреобразования", 				НастройкаТестов_СозданиеЗапросов.ОшибкиПреобразования());
			
			СтрокиНаполненияВТ = ТаблицаРезультатов.НайтиСтроки(Новый Структура("ВидСобытия", Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы));
			
			// Если выбраны Подготовленные операторы, то будем ориентироваться что для них обязательно выбрана строка с Определением подготовленного опрератора, 
			// Иначе слишком заморачиваться с добавлением этой строки, доделаю когда-нибудь потом
			СтрокиНаполненияВТ1 = ТаблицаРезультатов.НайтиСтроки(Новый Структура("ВидСобытия", Перечисления.ВидыСобытийЗапросов.ОпределениеПодготовленногоОператораВТ));
			Для каждого СтрокаТаблицы Из СтрокиНаполненияВТ1 Цикл 
				СтрокиНаполненияВТ.Добавить(СтрокаТаблицы);
			КонецЦикла;
			
			Если ЗначениеЗаполнено(СтрокиНаполненияВТ1) Тогда
				
				ДопТаблицы.Вставить("КолонкиВТПодготовленныхОператоров", НастройкаТестовСервер.ПустаяТаблицаРегистраСведений("КолонкиВТПодготовленныхОператоров")); 
				НастройкаТестовСервер.ДобавитьКолонкиИзмененияВТаблицу(ДопТаблицы.КолонкиВТПодготовленныхОператоров);
				ДопТаблицы.КолонкиВТПодготовленныхОператоров.Индексы.Добавить("НомерСессии,ИмяОператора");

				ДопТаблицы.Вставить("ИменаВТПодготовленныхОператоров", НастройкаТестовСервер.ПустаяТаблицаРегистраСведений("ИменаВТПодготовленныхОператоров")); 
				НастройкаТестовСервер.ДобавитьКолонкиИзмененияВТаблицу(ДопТаблицы.ИменаВТПодготовленныхОператоров);
				ДопТаблицы.ИменаВТПодготовленныхОператоров.Индексы.Добавить("НомерСессии,ИмяОператора,ДатаСоздания,НомерСобытия");
				
			КонецЕсли;
			
			Если ЗначениеЗаполнено(СтрокиНаполненияВТ) Тогда
				
				ВТ = НастройкаТестов_СозданиеВременныхТаблиц.ВременныеТаблицыMSSQL(НастройкаТеста);
				Если Не ЗначениеЗаполнено(ВТ) Тогда
					
					ТекстОшибки = "Нет данных по временным таблицам!";
					ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
					Результат.ОписаниеОшибки = ТекстОшибки;
					
					Возврат Результат;
					
				КонецЕсли;
				
				ДопТаблицы.Вставить("ВТ", 							ВТ);
				ДопТаблицы.Вставить("ПоляВременныхТаблицыPostgres", НастройкаТестов_СозданиеВременныхТаблиц.ДанныеРегистраДляИзменения(НастройкаТеста, "ПоляВременныхТаблицыPostgres"));
				ДопТаблицы.Вставить("СоответствиеИменТиповДанных", 	НастройкаТестов_СозданиеВременныхТаблиц.СоответствиеИменТиповДанных());
				
				// Если это ЗаполнениеВременнойТаблицы и по этому событию создавали ВТ, то очистим данные в РС ВременныеТаблицыPostgres и ПоляВременныхТаблицыPostgres
				Для каждого СтрокаТаблицы Из СтрокиНаполненияВТ Цикл
					
					ИмяТаблицы = НастройкаТестов_СозданиеВременныхТаблиц.ИмяВТ(СтрокаТаблицы.ТекстЗапросаMSSQL, "INSERT INTO #");
					СтруктураПоиска = Новый Структура("НомерСессии,ИмяТаблицы,НомерСобытия,ДатаСоздания");
					ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаТаблицы);
					СтруктураПоиска.ИмяТаблицы = ИмяТаблицы;
					СтруктураПоиска.ДатаСоздания = СтрокаТаблицы.ДатаСобытия;
					СтруктураПоиска.НомерСобытия = СтрокаТаблицы.НомерСобытия;
					
					СтрокиВТ = ДопТаблицы.ВременныеТаблицыPostgres.НайтиСтроки(СтруктураПоиска);
					Если ЗначениеЗаполнено(СтрокиВТ) Тогда
						
						//ДопТаблицы.ВременныеТаблицыPostgres.Удалить(СтрокиВТ[0]);
						НаборЗаписей = РегистрыСведений.ВременныеТаблицыPostgres.СоздатьНаборЗаписей(); 
						НаборЗаписей.Отбор.НастройкаТеста.Установить(НастройкаТеста);
						НаборЗаписей.Отбор.НомерСессии.Установить(СтрокаТаблицы.НомерСессии);
						НаборЗаписей.Отбор.ИмяТаблицы.Установить(ИмяТаблицы);
						НаборЗаписей.Отбор.ДатаСоздания.Установить(СтрокаТаблицы.ДатаСобытия);
						НаборЗаписей.Записать();
						
						НаборЗаписей = РегистрыСведений.ПоляВременныхТаблицыPostgres.СоздатьНаборЗаписей(); 
						НаборЗаписей.Отбор.НастройкаТеста.Установить(НастройкаТеста);
						НаборЗаписей.Отбор.ИмяТаблицы.Установить(ИмяТаблицы);
						НаборЗаписей.Отбор.ДатаСоздания.Установить(СтрокаТаблицы.ДатаСобытия);
						НаборЗаписей.Отбор.НомерСобытия.Установить(СтрокаТаблицы.НомерСобытия);
						НаборЗаписей.Отбор.НомерСессии.Установить(СтрокаТаблицы.НомерСессии);
						НаборЗаписей.Записать();
						
					КонецЕсли;
					
				КонецЦикла;
		
			КонецЕсли; 
			
			// Закоментил - буду вручную очищать, т.к. нужно отработать виды ошибок ПропускатьПриВыполнении - нужно конвертировать запросы, но возвращать на место этот вид ошибок.
			//ТаблицаРезультатов.ЗаполнитьЗначения(Перечисления.ВидыОшибокЗапросов.ПустаяСсылка(), "ВидОшибки"); 
			ТаблицаРезультатов.ЗаполнитьЗначения("", "ТекстОшибки");
			
			ПодготовитьТаблицуРезультатов(ТаблицаРезультатов); 
			ТаблицаРезультатов.Сортировать("ДатаСобытия,НомерСессии,НомерСобытия");

			ОбработатьСтрокиТаблицыРезультатов(НастройкаТеста, ТаблицаРезультатов, ДопТаблицы, , ПредставлениеОперации);	
			
			НачатьТранзакцию();
			
			НастройкаТестовСервер.ЗагрузитьДанныеВРегистр(НастройкаТеста, ТаблицаРезультатов);
			Если ЗначениеЗаполнено(СтрокиНаполненияВТ) Тогда
				НастройкаТестов_СозданиеВременныхТаблиц.СохранитьВременнуюТаблицы(НастройкаТеста, ДопТаблицы.ВременныеТаблицыPostgres, "ВременныеТаблицыPostgres", Истина);
				НастройкаТестов_СозданиеВременныхТаблиц.СохранитьВременнуюТаблицы(НастройкаТеста, ДопТаблицы.ПоляВременныхТаблицыPostgres, "ПоляВременныхТаблицыPostgres", Истина);
			КонецЕсли;
			//НастройкаТестовСервер.СообщитьДлительностьОперации(НастройкаТеста,СтрШаблон("Создание Временных таблиц %1 итерации данных", ЭтапОбработки.НомерИтерации), ДатаНачала); 
			
			ЗафиксироватьТранзакцию();
		
		КонецЕсли;
	
	Исключение
		
		НастройкаТестовСервер.СообщитьОшибку(НастройкаТеста, ПодразделЖР, ИнформацияОбОшибке(), Результат);
		
	КонецПопытки;
	
	НастройкаТестовСервер.СообщитьДлительностьОперации(НастройкаТеста, ПредставлениеОперации, ДатаНачала);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти 

#Область СлужебныеПроцедурыИФункции 

Процедура ОбработатьСтрокиТаблицыРезультатов(НастройкаТеста, ТаблицаРезультатов, ДопТаблицы, ЗаголовокСообщения = "", ТекстСообещения) Экспорт 
	
	ВерхнийРегистр = Новый Массив;
	ВерхнийРегистр.Добавить("numeric");
	
	Шагов = 10;
	Шаг = Цел(ТаблицаРезультатов.Количество() / Шагов) - 1;
	Если Шаг = 0 Тогда
		Шаг = 1;	
	КонецЕсли;
	Сч = 0;
	
	Для каждого СтрокаТаблицы Из ТаблицаРезультатов Цикл
										 
		Если НЕ ДопТаблицы.Многопоточность И Сч % Шаг = 0 Тогда
			НастройкаТестовСервер.СообщитьПрогрессаЭтапа(ЗаголовокСообщения, ТекстСообещения, Окр(Сч/ТаблицаРезультатов.Количество()*10, 0) * 10);
		КонецЕсли;
		Сч = Сч + 1; 
		
		СтрокаТаблицы.ТекстЗапросаPostgres = "";
		НастройкаТестовСервер.ЗаписьОтладки(НастройкаТеста, , СтрокаТаблицы.НомерСессии, СтрокаТаблицы.НомерСобытия);
		
		СтрокаТаблицы.ТекстЗапроса = НастройкаТестовСервер.ТекстЗапросаMSSQL(СтрокаТаблицы.ТекстЗапросаMSSQL, Истина);
		ТекстЗапросаMSSQL = НРег(СтрокаТаблицы.ТекстЗапросаMSSQL); 
		
		ТекстЗапросаMSSQL = ОбщиеДействияСТексомЗапроса(ТекстЗапросаMSSQL, ВерхнийРегистр);
		
		// Запоминаем ошибку ПропускатьПриВыполнении
		ПропускатьПриВыполнении = СтрокаТаблицы.ВидОшибки = Перечисления.ВидыОшибокЗапросов.ПропускатьПриВыполнении;
		СтрокаТаблицы.ВидОшибки = Перечисления.ВидыОшибокЗапросов.ПустаяСсылка();

		Если СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.СозданиеВременнойТаблицы Тогда	
			
			СтрокаТаблицы.ТекстЗапросаPostgres = НастройкаТестов_СозданиеВременныхТаблиц.СозданиеВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы);
			
		ИначеЕсли СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы Тогда 
			
			СтрокаТаблицы.ТекстЗапросаPostgres = ИсправлениеОбщегоЗапроса(НастройкаТеста, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы);
			СтрокаТаблицы.ТекстЗапросаPostgres = НастройкаТестов_СозданиеВременныхТаблиц.ИсправитьБинари1ВТекстеПриЗаполненииВТ(НастройкаТеста, СтрокаТаблицы, СтрокаТаблицы.ТекстЗапросаPostgres, ДопТаблицы);
			// Теоретически могут быть отдельные 0x01 во вложенных запросах
			СтрокаТаблицы.ТекстЗапросаPostgres = ИсправитьОтдельныеБинари1ВОбычномЗапросе(СтрокаТаблицы, СтрокаТаблицы.ТекстЗапросаPostgres, ДопТаблицы);
			СтрокаТаблицы.ТекстЗапросаPostgres = ИсправитьОтдельныеБинари1ВТексте(СтрокаТаблицы, СтрокаТаблицы.ТекстЗапросаPostgres, ДопТаблицы);
			НастройкаТестов_СозданиеВременныхТаблиц.ПроверкаСуществованияВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ТаблицаРезультатов, ДопТаблицы);
			
		ИначеЕсли СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ОчисткаВременнойТаблицы Тогда	
			
			СтрокаТаблицы.ТекстЗапросаPostgres = НастройкаТестов_СозданиеВременныхТаблиц.ИсправлениеОчисткиВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы); 
			
		ИначеЕсли СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ОпределениеПодготовленногоОператораВТ Тогда	
			
			СтрокаТаблицы.ТекстЗапросаPostgres = НастройкаТестов_СозданиеВременныхТаблиц.ИсправлениеОпределениеПодготовленногоОператораВТ(НастройкаТеста, ТаблицаРезультатов, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы); 
			
		ИначеЕсли СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ВызовПодготовленногоОператораВТ Тогда	
			
			СтрокаТаблицы.ТекстЗапросаPostgres = НастройкаТестов_СозданиеВременныхТаблиц.ИсправлениеВызовПодготовленногоОператораВТ(НастройкаТеста, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы); 
			
		ИначеЕсли СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.РазрушениеПодготовленногоОператораВТ Тогда	
			
			СтрокаТаблицы.ТекстЗапросаPostgres = НастройкаТестов_СозданиеВременныхТаблиц.ИсправлениеРазрушениеПодготовленногоОператораВТ(НастройкаТеста, СтрокаТаблицы, ДопТаблицы); 
			
		ИначеЕсли СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ВыборкаДанных Тогда 
			
			СтрокаТаблицы.ТекстЗапросаPostgres = ИсправлениеОбщегоЗапроса(НастройкаТеста, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы);
			СтрокаТаблицы.ТекстЗапросаPostgres = ИсправитьОтдельныеБинари1ВОбычномЗапросе(СтрокаТаблицы, СтрокаТаблицы.ТекстЗапросаPostgres, ДопТаблицы);
			СтрокаТаблицы.ТекстЗапросаPostgres = ИсправитьОтдельныеБинари1ВТексте(СтрокаТаблицы, СтрокаТаблицы.ТекстЗапросаPostgres, ДопТаблицы);
			
		ИначеЕсли СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.СозданиеИндексаВременнойТаблицы Тогда 
			
			СтрокаТаблицы.ТекстЗапросаPostgres = НастройкаТестов_СозданиеВременныхТаблиц.СозданиеИндексаВременнойТаблицы(НастройкаТеста, СтрокаТаблицы, ТекстЗапросаMSSQL, ДопТаблицы); 
			
		Иначе
			
			СтрокаТаблицы.ВидОшибки = Перечисления.ВидыОшибокЗапросов.ПропущенныйЗапросPostgres;
			
		КонецЕсли;
		
		Если СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ВыборкаДанных Тогда
			НастройкаТестов_УстановкаСвязанныхЗапросов.ПроверитьСвязьСОшибкамиВТ(СтрокаТаблицы, , ДопТаблицы);
		КонецЕсли;
		
		// Возвращаем на место ошибку ПропускатьПриВыполнении
		Если ПропускатьПриВыполнении Тогда
			СтрокаТаблицы.ВидОшибки = Перечисления.ВидыОшибокЗапросов.ПропускатьПриВыполнении;
		КонецЕсли;
		
	КонецЦикла; 
		
КонецПроцедуры

Процедура ПодготовитьТаблицуРезультатов(ТаблицаРезультатов) Экспорт 
	
	ТаблицаРезультатов.ЗаполнитьЗначения(Справочники.ОшибкиПреобразования.ПустаяСсылка(), "ОшибкаПреобразования"); 
	ТаблицаРезультатов.ЗаполнитьЗначения(0, "КоличествоСтрокPostgres"); 
	ТаблицаРезультатов.ЗаполнитьЗначения(0, "ДлительностьВыполненияPostgres"); 
	//ТаблицаРезультатов.ЗаполнитьЗначения("", "ПроизвольнаяИнформация"); 
	ТаблицаРезультатов.Колонки.Добавить("ТекстЗапроса", Новый ОписаниеТипов("Строка", ,
									 Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	ТаблицаРезультатов.Колонки.Добавить("ПланЗапроса"); // при необходимости елси нужно получать структуру запроса в сложных случаях, то он будет получен в виде массива
	ТаблицаРезультатов.Колонки.Добавить("СтроковыеПараметры"); // Если есть строковые параметры, то загоняем их сюда, а в тексте запроса остаются все так же @P иначе тяжело создавать план запроса
		
КонецПроцедуры

Функция ОбщиеДействияСТексомЗапроса(Знач ТекстЗапросаMSSQL, ВерхнийРегистр) Экспорт 
	
	Результат = ТекстЗапросаMSSQL;
	
	// Установка верхнего регистра
	Для каждого Строка Из ВерхнийРегистр Цикл
		Результат = СтрЗаменить(Результат, Строка, ВРег(Строка));		
	КонецЦикла;
	
	Результат = СтрЗаменить(Результат, "varbinary(max)", "binary");		
	Результат = СтрЗаменить(Результат, "varbinary", "binary");		
	
	// БЛЛЯЯЯЯЯТЬЬЬЬЬ еле нешел, зачем убрал n?????????
	// Меняем двойные одиночные кавычки на одиночные в строках
	//Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\bn'('[\w а-яА-Я]*')'", "$1");
	
	Возврат Результат
	
КонецФункции

Функция ИсправлениеОбщегоЗапроса(НастройкаТеста, СтрокаТаблицы, Знач ТекстЗапроса, ДопТаблицы) Экспорт 
	
	Результат = СтрЗаменить(ТекстЗапроса, " with(tablock)", "");
	Результат = СтрЗаменить(Результат, " with(nolock)", "");
	Результат = СтрЗаменить(Результат, " dbo.", " ");
	Результат = НастройкаТестов_СозданиеВременныхТаблиц.ИсправитьИменаВТЗапроса(Результат);
	
	// Должен быть перед ЗаменитьПараметрыВЗапросе, т.к. бинарные строки может быть и в параметрах
	Результат = ИсправитьБинарнойСтрокиНаBytea(Результат);
	
	Результат = ЗаменитьПараметрыВЗапросе(СтрокаТаблицы, Результат, ДопТаблицы);
	
	Результат = ИсправитьТипыДанных(ДопТаблицы.СоответствиеТиповДанных, Результат); 
	
	Результат = ИсправитьФункции(СтрокаТаблицы, Результат, ДопТаблицы);
	
	// Вынес из исходной функции часть в ИсправитьОтдельныеБинари1ВТексте, что бы была возможность вствить до нее ИсправитьБинари1ВТекстеПриЗаполненииВТ
	Результат = ИсправитьБинари1ВТексте(НастройкаТеста, СтрокаТаблицы, Результат, ДопТаблицы.ОшибкиПреобразования);
	
	ЗаполнитьПланЗапроса(СтрокаТаблицы, Результат, ДопТаблицы);
	
	Результат = ИсправитьTOPВЗапросе(СтрокаТаблицы, Результат, ДопТаблицы);
	
	Возврат Результат;
	
КонецФункции

Функция ИсправитьTOPВЗапросе(СтрокаТаблицы, Знач Результат, ДопТаблицы)
	
	ЕстьUnion = СтрНайтиПоРегулярномуВыражению(Результат, "\s+union\s+").Длина > 0;
	РезультатыПоиска = СтрНайтиВсеПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.ШаблонTOP());
	КоличествоTOP = РезультатыПоиска.Количество(); 

	Если КоличествоTOP > 1 Или ЕстьUnion И КоличествоTOP > 0 Тогда                
		
		Результат = ИсправитьTOPВОтдельномЗапросе(СтрокаТаблицы.ПланЗапроса.ЗапросИсточник, , СтрокаТаблицы, Результат, КоличествоTOP, ДопТаблицы.ОшибкиПреобразования);
		
	// Если это простой случай - один селект и нет юнионов, то и нет плана запроса
	ИначеЕсли КоличествоTOP = 1 Тогда
		
		TOP = РезультатыПоиска[0].ПолучитьГруппы()[2].Значение;
		КоличествоTOP = 0;
		ПодстрокаЗамены = СтрШаблон(" LIMIT %1", TOP); 
		
		Результат = СтрШаблон("%1%2", Результат, ПодстрокаЗамены);
		Результат = СтрЗаменить(Результат, РезультатыПоиска[0].Значение, СтрШаблон("%1%2", РезультатыПоиска[0].ПолучитьГруппы()[0].Значение));
		
	КонецЕсли; 
	
	Если КоличествоTOP > 0 Тогда
		
		УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "СложныйЗапросTOP",,ДопТаблицы.Многопоточность); 
		
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

Функция ИсправитьTOPВОтдельномЗапросе(ЗапросИсточник, ПсевдонимРодителя = Неопределено,СтрокаТаблицы, Знач Результат, КоличествоTOP, ОшибкиПреобразования)

	ПодстрокаЗапроса = "\bselect\b";
	Сч = 0;
	Для каждого ПолеИсточник Из ЗапросИсточник Цикл
		
		Если ЗначениеЗаполнено(ПолеИсточник.Первые) Тогда
			// Начало текущего селекта
			//ПозНач = СтрНайтиПоРегулярномуВыражению(Результат, ПодстрокаЗапроса,, , ПолеИсточник.НомерВыборки).НачальнаяПозиция;
				
			РезультатПоиска = СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.ШаблонTOP(),,Число(ПолеИсточник.НомерВыборки));
			// Удаляем топ из селекта
			Результат = НастройкаТестовКлиентСервер.ВыполнитьОдиночнуюЗамену(Результат, РезультатПоиска.НачальнаяПозиция, РезультатПоиска.Значение, "(" + РезультатПоиска.ПолучитьГруппы()[0].Значение);
			
			// Определяем место вставки лимита. Он может быть как и в текущем запросе - если есть юнионы и дальше есть еще один запрос - это как раз юнион перед следующим селектом, 
			// то по позиции этого следующего селекта
			Если ЗапросИсточник.ВГраница() > Сч Тогда
				
				ПозСлед = СтрНайтиПоРегулярномуВыражению(Результат, ПодстрокаЗапроса,, , Число(ЗапросИсточник[Сч + 1].НомерВыборки)).НачальнаяПозиция;
				ПозКон = СтрНайтиПоРегулярномуВыражению(Результат, "\bunion\b", НаправлениеПоиска.СКонца, ПозСлед).НачальнаяПозиция;
				
			// Если это последний или единственный запрос в этом блоке, если псевдоним не задан, то это будет конец запроса
			ИначеЕсли ПсевдонимРодителя = Неопределено Тогда
				
				ПозКон = СтрДлина(Результат) + 2;
				
			// Если это последний или единственный запрос в этом блоке, то ориентируеся на псевдоним этого блока
			Иначе
			
				ПозКон = СтрНайтиПоРегулярномуВыражению(Результат, СтрШаблон("(\))\s+%1(\s|\z)", ПсевдонимРодителя),,РезультатПоиска.НачальнаяПозиция).ПолучитьГруппы()[0].НачальнаяПозиция + 1;	
				
			КонецЕсли; 
			
			// Вставляем лимит
			Результат = НастройкаТестовКлиентСервер.ВыполнитьОдиночнуюЗамену(Результат, ПозКон - 1, "", СтрШаблон(" LIMIT %1) ", ПолеИсточник.Первые));
			КоличествоTOP = КоличествоTOP - 1;
			
			Если КоличествоTOP = 0 Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПолеИсточник.ОсновнаяТаблица.Запрос <> Неопределено Тогда
			
			Результат = ИсправитьTOPВОтдельномЗапросе(ПолеИсточник.ОсновнаяТаблица.Запрос.ЗапросИсточник, ПолеИсточник.ОсновнаяТаблица.Псевдоним, СтрокаТаблицы, Результат, КоличествоTOP, ОшибкиПреобразования);
			
			Если КоличествоTOP = 0 Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЕсли;
		
		Сч = Сч + 1;
		
	КонецЦикла;
			
	Возврат Результат;
		
КонецФункции

Функция РазделитьПолеСТипом(Знач ДанныеПоля, СоответствиеТиповДанных = Неопределено) Экспорт 
	// Вход например _q_000_f_002_n numeric(1, 0), на выходе массив [_q_000_f_002_n] И [тип], если СоответствиеТиповДанных передано, то исправляется тип
	ДанныеПоля = СокрЛП(ДанныеПоля);
	ДанныеПоля = СтрЗаменить(ДанныеПоля, "  ", " ");
	
	ПозНач = СтрНайти(ДанныеПоля, " ");
	Результат = Новый Массив;
	Результат.Добавить(Лев(ДанныеПоля, ПозНач - 1));
	Тип = Прав(ДанныеПоля, СтрДлина(ДанныеПоля) - ПозНач);
	Если ЗначениеЗаполнено(СоответствиеТиповДанных) Тогда
		Если Тип = "binary(1)" Тогда
			Тип = ТипБинари1(Результат[0]);
		Иначе
			Тип = ИсправитьТипыДанных(СоответствиеТиповДанных, Тип, Истина);
		КонецЕсли;
	КонецЕсли;
	Результат.Добавить(Тип);
	
	Возврат Результат;
		
КонецФункции 

Функция ИсправитьБинари1ВТексте(НастройкаТеста, СтрокаТаблицы, Знач Результат, ОшибкиПреобразования)
	
	Если СтрНайтиПоРегулярномуВыражению(Результат, "\b0x01\b").Длина > 0 Тогда
		
		// Замена по регулярным выражениям. ПОСЛЕДОВАТЕЛЬНОСТЬ ВАЖНА 
		
		// Разбор конструкции когда 0x01 в скобках окруженная через запятую байтишками in ('\\x08'::BYTEA, 0x01, '\\x08'::BYTEA)
		// Можем заменять только если в скобках есть хоть одна байтишка, заменяем в цикле, пока не закончатся поиски 
		// Идем последовательно, т.к. при замене сдвигаются позиции поиска
		ШаблонБайти = "'\\\\x[0-9a-f]{2}'::BYTEA"; 
		Пока Истина Цикл
			
			Заменили = Ложь;
			
			РезультатыПоиска = СтрНайтиВсеПоРегулярномуВыражению(Результат, "(\bin\s*\(('\\\\x[0-9a-f]{2}'::BYTEA, )*)0x01(,\s+('\\\\x[0-9a-f]{2}'::BYTEA|0x01)*\))");
			Для каждого РезультатПоиска Из РезультатыПоиска Цикл
				Группы = РезультатПоиска.ПолучитьГруппы();
				Если СтрНайти(Группы[0].Значение, "::BYTEA") > 0 Или СтрНайти(Группы[2].Значение, "::BYTEA") > 0 Тогда
					Заменили = Истина; 
					Результат = СтрЗаменить(Результат, РезультатПоиска.Значение, СтрШаблон("%1%2%3", Группы[0].Значение, "'\\001'::BYTEA", Группы[2].Значение));
					Прервать;
				КонецЕсли;	
			КонецЦикла;
			
			Если Не Заменили Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЦикла;
		
		// Замена по имени псевдонима заканчивающийся на _type для 0x01, например 0x01 as _q_000_f_005_type. За один раз не получается, смежные значения не берет поэтому в цикле
		Шаблон = "((select(\s+top\s+\d?)?(\s+distinct)?\s+|\v|,)\s*\(*)0x01(\)*\s+as\s+[a-z0-9_]{4,12}_type\s*(from|,|\z))";
		Пока Истина Цикл
			
			РезультатПоиска = СтрНайтиПоРегулярномуВыражению(Результат, Шаблон);
			Если РезультатПоиска.НачальнаяПозиция = 0 Тогда
				Прервать;	
			КонецЕсли;
			
			Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, Шаблон, "$1'\\\\001'::BYTEA$5", Ложь, Ложь);
			
		КонецЦикла;
		
		// Замена по имени псевдонима заканчивающийся НЕ на _type для 0x01, например 0x01 as _q_000_f_005. За один раз может не получится, смежные значения не берет поэтому в цикле.
		// В отличии от _type добавил еще в конец закрывающую скобку для случая Exist
		//exists(select
		//	TRUE as q_001_f_000_
		//	from (select
		//	0x01 as q_001_f_000_) t3
		Шаблон = "((select(\s+top\s+\d?)?(\s+distinct)?\s+|\v|,)\s*\(*)0x01(\)*\s+as\s+[a-z0-9_]{3,16}\s*(from|,|\z|\)))";
		Пока Истина Цикл
			
			РезультатПоиска = СтрНайтиПоРегулярномуВыражению(Результат, Шаблон);
			Если РезультатПоиска.НачальнаяПозиция = 0 Тогда
				Прервать;	
			КонецЕсли;
			
			Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, Шаблон, "$1TRUE$5", Ложь, Ложь);
			
		КонецЦикла;
		
		// Замена подзапроса RLS вида: 0x01 in (0x01, 0x01, FALSE, 0x01, FALSE, 0x01)
		РезультатыПоиска = СтрНайтиВсеПоРегулярномуВыражению(Результат, "0x01\s+in\s+\(((FALSE|0x01),?\s*)+\)");
		Для каждого РезультатПоиска Из РезультатыПоиска Цикл
			Результат = СтрЗаменить(Результат, РезультатПоиска.Значение, СтрЗаменить(РезультатПоиска.Значение, "0x01", "TRUE"));	
		КонецЦикла;
		
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bCOALESCE\(\s*\(*[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\)*\s*,\s*\(*)0x01(\)*\s*\))", "$1'\\\\001'::BYTEA$2", Ложь, Ложь); // COALESCE(  (t5._fld40406_type)  ,  (0x01)  ) 
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bCOALESCE\(\s*\(*[a-z]\d{1,3}\.[a-z0-9_]{4,16}\)*\s*,\s*\(*)0x01(\)*\s*\))", "$1TRUE$2", Ложь, Ложь); // COALESCE(t2._q_001_f_004, 0x01) 
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\)* else \(*)0x01(\)* end)", "$1'\\\\001'::BYTEA$2", Ложь, Ложь); // then (t1._q_000_f_005_type) else (0x01) end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*)0x01(\)* else \(*\(*[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\)* end\b)", "$1'\\\\001'::BYTEA$2", Ложь, Ложь); // then (0x01) else (t1._q_000_f_005_type) end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*[a-z]\d{1,3}\.[a-z0-9_]{4,16}\)* else \(*)0x01(\)* end\b)", "$1TRUE$2", Ложь, Ложь); // then (t1._q_000_f_005) else (0x01) end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*)0x01(\)* else \(*\(*[a-z]\d{1,3}\.[a-z0-9_]{4,12}\)*\)* end\b)", "$1TRUE$2", Ложь, Ложь); // then (0x01) else (t1._q_000_f_005) end 
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "([a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\)*\s*)(=|<>|>|>=|<|<=|in)(\s*\(*)0x01\b", "$1$2$3'\\\\001'::BYTEA", Ложь, Ложь); // Имя поля заканчивается на _type: T1._Q_000_F_016_type)) = ((0x01 или ._fld767_type <> 0x01 или snull(T2._Q_000_F_004_type,0x01)
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "([a-z]\d{1,3}\.[a-z0-9_]{4,16}\)*\s*)(=|<>|>|>=|<|<=|in)(\s*\(*)0x01\b", "$1$2$3TRUE", Ложь, Ложь); // Оставшиеся сравнения, когда не заканчивается на _type: T1._Q_000_F_000) =(0x01 T1_Q_000_F_000) <>(0x01
		
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "((\bas\s+|::)BYTEA\)*(\s+end)?\s*(=|<>|>|>=|<|<=)\s*)0x01", "$1'\\\\001'::BYTEA", Ложь, Ложь); // as BYTEA) end = 0x01 или and ('\\x03'::BYTEA >= 0x01) and (t3._fld1974 <
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bas\s+BOOLEAN\)(\s+end)?\s*(=|<>|>|>=|<|<=)\s*)0x01", "$1TRUE", Ложь, Ложь); // as BOOLEAN) end = 0x01
		//Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(then|else)\s*\(*)0x01(\)*(\s*end\)*)*\s*=\s*)0x01\b", "$1TRUE$3TRUE", Ложь, Ложь); //  then (0x01) end = 0x01)
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\b(where\s+)0x01(\s+in\s*\()", "$1TRUE$2", Ложь, Ложь); // where 0x01 in (select
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b\(*)0x01(\)* (=|<>|>|>=|<|<=) \(*)0x01(\)*\b)", "$1TRUE$2TRUE$4", Ложь, Ложь); // 0x01) <> (0x01)
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b\(*(FALSE|TRUE)\)* (=|<>|>|>=|<|<=) \(*)0x01(\)*\b)", "$1TRUE$4", Ложь, Ложь); //  FALSE) <> (0x01)
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b\(*)0x01(\)* (=|<>|>|>=|<|<=) \(*(FALSE|TRUE)\)*\b)", "$1TRUE$2", Ложь, Ложь); //   0x01) <> (FALSE) 
		
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\belse (FALSE|TRUE) end\)* = )0x01\b", "$1TRUE", Ложь, Ложь); // else FALSE end) = 0x01
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(then|else) \(*'\\\\x[0-9a-f]{2}'::BYTEA\)* end,\s*)0x01(\))", "$1'\\\\001'::BYTEA$3", Ложь, Ложь); // then '\\x08'::BYTEA end,0x01) - сложный запрос Внутри isnull идет case и заканчивается на эту подстрорку
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*)0x01(\)* (end else|else) \(*'\\\\x[0-9A-F]{2}'::BYTEA\)* end\b)", "$1'\\\\001'::BYTEA$2", Ложь, Ложь); // then 0x01 else '\\x08'::BYTEA end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*'\\\\x[0-9a-f]{2}'::BYTEA\)* (end else|else) \(*)0x01(\)* end\b)", "$1'\\\\001'::BYTEA$3", Ложь, Ложь); // then '\\x08'::BYTEA else 0x01 end ИЛИ then '\\x08'::BYTEA end else 0x01 end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "((then|else)\s+'\\\\x[0-9a-f]*'::BYTEA\s+end\)*\s*=\s*)0x01\b", "$1'\\\\001'::BYTEA", Ложь, Ложь); // null then '\\x04'::BYTEA end = 0x01 
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*)0x01(\)* else \(*FALSE\)* end\b)", "$1TRUE$2", Ложь, Ложь); // then 0x01 else FALSE end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*FALSE\)* else \(*)0x01(\)* end\b)", "$1TRUE$2", Ложь, Ложь); // then (FALSE) else (0x01) end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen\s+\(*)0x01(\)*\s+else\s+\(*FALSE\)*\s+end\b)", "$1TRUE$2", Ложь, Ложь); // then (0x01) else (FALSE) end
		
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(,\s*('\\\\(x[0-9a-f]{2}|001)'::BYTEA|[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type)\)+\s+(in|=|<>|>|>=|<|<=)\s+\(*)0x01", "$1'\\\\001'::BYTEA", Ложь, Ложь); // COALESCE(t193._q_000_f_028_type,'\\x08'::BYTEA) in (0x01) либо любой байтишник, или поле заканчивающееся на _type
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(,\s*[a-z]\d{1,3}\.[a-z0-9_]{4,16}\)+\s+(in|=|<>|>|>=|<|<=)\s+\(*)0x01", "$1TRUE", Ложь, Ложь); // COALESCE(t193._q_000_f_028_type,t193._q_000_f_028) in (0x01)
		
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "([a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\)*\s*,\s*)0x01\)", "$1'\\\\001'::BYTEA)", Ложь, Ложь); // Имя поля заканчивается на _type: T1._Q_000_F_016_type, 0x01)
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "([a-z]\d{1,3}\.[a-z0-9_]{4,16}\)*\s*,\s*)0x01\)", "$1TRUE)", Ложь, Ложь); // Оставшиеся сравнения, когда не заканчивается на _type: T1._Q_000_F_000, 0x01)
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "0x01(\)*\s*(=|<>|>|>=|<|<=)\s*\(*[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\b)", "'\\\\001'::BYTEA$1", Ложь, Ложь); // 0x01 <> t1._q_001_f_022_type
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "0x01(\)*\s*(=|<>|>|>=|<|<=)\s*\(*[a-z]\d{1,3}\.[a-z0-9_]{4,16}\b)", "TRUE$1", Ложь, Ложь); // 0x01 <> t1._q_001_f_022_
		
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen\s+\(*(FALSE|TRUE)\)*\s+end\s+else\s+\(*)0x01(\)*\s+end\b)", "$1TRUE$3", Ложь, Ложь); // then FALSE end else 0x01 end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b((then|else)\s+\(*(FALSE|TRUE)\)*)\s+end\)* (then|else)\s+\(*){1}0x01\b", "$1TRUE", Ложь, Ложь); // else (FALSE) end) else (0x01
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(else|then)\s+[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\s+end\s*=\s)0x01\b", "$1'\\\\001'::BYTEA", Ложь, Ложь); // else t13._fld14585_type end = 0x01
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(else|then)\s+[a-z]\d{1,3}\.[a-z0-9_]{4,16}\s+end\s*=\s)0x01\b", "$1TRUE", Ложь, Ложь); // else t13._fld14585_ end = 0x01
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(then|else)\s+[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\s+end\s+else+\s+)0x01(\s+end\b)", "$1'\\\\001'::BYTEA$3", Ложь, Ложь); // else t2._q_001_f_007_type end else 0x01 end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(then|else)\s+[a-z]\d{1,3}\.[a-z0-9_]{4,16}\s+end\s+else+\s+)0x01(\s+end\b)", "$1'TRUE$3", Ложь, Ложь); // else t2._q_001_f_007_ end else 0x01 end
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(else|then)\s+[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\s+end\)*\s+in\s+\()0x01\b", "$1'\\\\001'::BYTEA", Ложь, Ложь); // else t82._q_000_f_005_type end in (0x01)
		
		// Должен быть ближе к концу
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(then|else)\s+'\\\\(x[0-9a-f]+|001)'::BYTEA\s+(end\s+){1,}(in|=|<>|>|>=|<|<=)\s*\(*)0x01\b", "$1'\\\\001'::BYTEA", Ложь, Ложь); // else '\\001'::BYTEA end in (0x01)
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(then|else)\s*\(*(FALSE|TRUE)\)*\s*end\)*\s*end\)*\s*=\s*\(*)0x01\b", "$1TRUE", Ложь, Ложь); // then (FALSE) end)) end = 0x01)
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(else|then) \(*(FALSE|TRUE)\)* end\)* = \(*)0x01\b", "$1TRUE", Ложь, Ложь); // else (TRUE) end) = (0x01
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(FALSE|TRUE)\)* = \(*)0x01\b", "$1TRUE", Ложь, Ложь); // (TRUE) = (0x01
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(else|then) \(*(FALSE|TRUE)\)* (end\)* end|end)\)* (=|<>|>|>=|<|<=) \(*)0x01\b", "$1TRUE", Ложь, Ложь); //  else TRUE end = 0x01 или else FALSE end end = 0x01
		
	КонецЕсли; 
	
	Если СтрНайтиПоРегулярномуВыражению(Результат, "\b0x01\b").Длина > 0 Тогда
		// Получаем таблицу замен 0x01, находящися в констукциямх case...end
		ТаблицаЗамен = ТаблицаЗаменCase(Результат);

		Если ЗначениеЗаполнено(ТаблицаЗамен) Тогда
			
			// Заменяем найденные варианты, уже учли, что находящаяся выше строка может быть частью кейса из строки ниже
			Для каждого СтрокаЗамены Из ТаблицаЗамен Цикл
				Результат = СтрЗаменить(Результат, СтрокаЗамены.ПодстрокаПоиска, СтрокаЗамены.ПодстрокаЗамены);	
			КонецЦикла;
			
		КонецЕсли;
		
		// После замены кейсов можно заменить конструкции then 0x01 end = 0x01) на TRUE их много
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\bthen \(*)0x01(\)* else \(*)0x01(\)* (end\)* end|end)\)*( (=|<>|>|>=|<|<=) )\(*)0x01\b", "$1TRUE$2TRUE$3TRUE", Ложь, Ложь); //  then 0x01 else 0x01 end = 0x01
		Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\b(else|then) \(*)0x01(\)* (end\)* end|end)\)*( (=|<>|>|>=|<|<=) )\(*)0x01\b", "$1TRUE$3TRUE", Ложь, Ложь); //  else TRUE end = 0x01 или else FALSE end end = 0x01
		
	КонецЕсли;  
	
	Возврат Результат;
		
КонецФункции 

// Получаем таблицу замен 0x01, находящися в констукциямх case...end
Функция ТаблицаЗаменCase(Результат, ДобавлятьПоиск0x01 = Истина)

	// Если осталось еще 0x01, то пробуем искать в конструкциях case
	РегШаблоны = Новый Массив;
	Если ДобавлятьПоиск0x01 Тогда
		РегШаблоны.Добавить(НастройкаТестовКлиентСервер.Шаблон0x01вCase());
	КонецЕсли;
	РегШаблоны.Добавить("\bcase\swhen\b");
	РегШаблоны.Добавить("\b(then|else)\b");
	РегШаблоны.Добавить("\bend\b");
	ТаблицаCase = Новый ТаблицаЗначений; // таблица с позициями подстрок case или end - начало и конец блока
	ТаблицаCase.Колонки.Добавить("Оператор", 			ОбщегоНазначения.ОписаниеТипаСтрока(50)); // Подстрока поиска case, end и т.д.
	ТаблицаCase.Колонки.Добавить("Значение", 			ОбщегоНазначения.ОписаниеТипаСтрока(50));
	ТаблицаCase.Колонки.Добавить("НачальнаяПозиция", 	ОбщегоНазначения.ОписаниеТипаЧисло(10)); 
	ТаблицаCase.Колонки.Добавить("НомерCase", 			ОбщегоНазначения.ОписаниеТипаЧисло(10)); // Если 1 - то это самый верхний уровень, если больше - то уровень ниже
	ТаблицаCase.Колонки.Добавить("ИндРодителя", 		ОбщегоНазначения.ОписаниеТипаЧисло(10)); // Индекс строки родителя, к которому относится блок
	
	Для каждого Шаблон Из РегШаблоны Цикл
		РезультатыПоиска = СтрНайтиВсеПоРегулярномуВыражению(Результат, Шаблон); 
		Если РезультатыПоиска.Количество() > 0 Тогда
			Для каждого РезультатПоиска Из РезультатыПоиска Цикл
				НоваяСтрока = ТаблицаCase.Добавить();
				НоваяСтрока.Оператор = Шаблон;
				НоваяСтрока.Значение = РезультатПоиска.Значение;
				НоваяСтрока.НачальнаяПозиция = РезультатПоиска.НачальнаяПозиция;
			КонецЦикла;
		Иначе
			ТаблицаCase.Очистить();
			Прервать;
		КонецЕсли;	
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ТаблицаCase) Тогда
		
		// Шаблоны подстрок после других then или else которые показывают на тип 0x01
		ШаблоныБайти = Новый Массив;
		ШаблоныБайти.Добавить("\b(then|else)\s*\(*(COALESCE\()?[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\b");
		ШаблоныБайти.Добавить("\b(then|else)\s*\(*'\\\\(x[0-9a-f]{2}|001)'::BYTEA\b");
		
		ШаблоныTrue = Новый Массив;
		ШаблоныTrue.Добавить("\b(then|else)\s*\(*(COALESCE\()?[a-z]\d{1,3}\.[a-z0-9_]{4,16}\b");
		ШаблоныTrue.Добавить("\b(then|else)\s*\(*(TRUE|FALSE)\b"); 
		
		ТаблицаЗамен = Новый ТаблицаЗначений;
		ТаблицаЗамен.Колонки.Добавить("ПодстрокаПоиска", ОбщегоНазначения.ОписаниеТипаСтрока(0));
		ТаблицаЗамен.Колонки.Добавить("ПодстрокаЗамены", ОбщегоНазначения.ОписаниеТипаСтрока(0));
		ТаблицаЗамен.Колонки.Добавить("ИндCASE", ОбщегоНазначения.ОписаниеТипаЧисло(5));
		ТаблицаЗамен.Колонки.Добавить("ИндEND", ОбщегоНазначения.ОписаниеТипаЧисло(5));
		ТаблицаЗамен.Колонки.Добавить("ДлинаСтроки", ОбщегоНазначения.ОписаниеТипаЧисло(10));
		ТаблицаЗамен.Колонки.Добавить("ЭтоБулево", Новый ОписаниеТипов("Булево")); // Признак что текущее 0x01 это булево 
		
		ТаблицаCase.Сортировать("НачальнаяПозиция,Оператор");
		
		Строки0x01 = ТаблицаCase.НайтиСтроки(Новый Структура("Оператор", НастройкаТестовКлиентСервер.Шаблон0x01вCase()));
		// Если нужно искусствено добавить 0x01 - для распарсивания case end
		Если Строки0x01.Количество() = 0 И Не ДобавлятьПоиск0x01 Тогда
			
			НоваяСтрока = ТаблицаCase.Вставить(1);
			НоваяСтрока.Оператор = НастройкаТестовКлиентСервер.Шаблон0x01вCase();
			НоваяСтрока.Значение = "0x01";
			НоваяСтрока.НачальнаяПозиция = 20;
			Строки0x01 = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(НоваяСтрока);
			
		КонецЕсли;
		
		// Расставим номера case
		НомерCase = -1;
		Родители = Новый Соответствие;
		Родители.Вставить(0, 0);
		Для каждого СтрокаТаблицы Из ТаблицаCase Цикл
			
			Если СтрокаТаблицы.Оператор = "\bcase\swhen\b" Тогда
				НомерCase = НомерCase + 1;
				Если НомерCase > 0 И ТаблицаCase[ТаблицаCase.Индекс(СтрокаТаблицы) - 1].Оператор <> "\bend\b" Тогда
					Родители.Вставить(НомерCase, ТаблицаCase.Индекс(СтрокаТаблицы) - 1);
				КонецЕсли;
			КонецЕсли;
			
			СтрокаТаблицы.НомерCase = НомерCase;
			СтрокаТаблицы.ИндРодителя = Родители.Получить(НомерCase);
			
			Если СтрокаТаблицы.Оператор = "\bend\b" Тогда	
				НомерCase = НомерCase - 1;
			КонецЕсли;
			
		КонецЦикла;
		
		Для каждого Строка0x01 Из Строки0x01 Цикл
			
			Инд0x01 = ТаблицаCase.Индекс(Строка0x01);
			//Если Инд0x01 > 0 И Инд0x01 < ТаблицаCase.Количество() Тогда 
			Если Строка0x01.НомерCase >= 0 Тогда 
				
				// Ищем ИндCASE - индекс строки с кейсом, который относится с текущему Инд0x01
				ИндCASE = Инд0x01;
				Пока Истина Цикл
					ИндCASE	= ИндCASE - 1;
					Если ТаблицаCase[ИндCASE].НомерCase = Строка0x01.НомерCase И ТаблицаCase[ИндCASE].Оператор = "\bcase\swhen\b" Тогда
						Прервать;	
					КонецЕсли;
				КонецЦикла;
				
				// Ищем ИндEND - индекс строки с эндом, который относится с текущему Инд0x01
				ИндEND = Инд0x01;
				Пока Истина Цикл
					ИндEND	= ИндEND + 1;
					Если ТаблицаCase[ИндEND].НомерCase = Строка0x01.НомерCase И ТаблицаCase[ИндEND].Оператор = "\bend\b" Тогда
						Прервать;	
					КонецЕсли;
				КонецЦикла;
				
				ПодстрокаПоиска = Сред(Результат, ТаблицаCase[ИндCASE].НачальнаяПозиция, ТаблицаCase[ИндEND].НачальнаяПозиция - ТаблицаCase[ИндCASE].НачальнаяПозиция); 
				// Если такая подстрока уже есть, то ничего делать не нужно. Построки уникальны и их можно менять все разом
				Если ТаблицаЗамен.Найти(ПодстрокаПоиска, "ПодстрокаПоиска") <> Неопределено Тогда
					Продолжить;	
				КонецЕсли; 
				
				// Нужно учесть что кейсы, которые определили выше могуть входить в текущий кейс, например:
				//           case when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x0000C222'::BYTEA then t5._fld104134rref when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x00000094'::BYTEA then t6._fld104132rref else cast(null as BYTEA) end =  '\\xB37C9BC25ED146F8459F5CFCC5F8F4DA'::BYTEA) then 0x01 when not (case when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x0000C222'::BYTEA then t5._fld104134rref when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x00000094'::BYTEA then t6._fld104132rref else cast(null as BYTEA) end =  '\\xB37C9BC25ED146F8459F5CFCC5F8F4DA'::BYTEA) then FALSE 
				//case when (case when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x0000C222'::BYTEA then t5._fld104134rref when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x00000094'::BYTEA then t6._fld104132rref else cast(null as BYTEA) end =  '\\xB37C9BC25ED146F8459F5CFCC5F8F4DA'::BYTEA) then 0x01 when not (case when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x0000C222'::BYTEA then t5._fld104134rref when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x00000094'::BYTEA then t6._fld104132rref else cast(null as BYTEA) end =  '\\xB37C9BC25ED146F8459F5CFCC5F8F4DA'::BYTEA) then FALSE end end = TRUE then 0x01 when not ((t2._fld90279rref =  '\\xB9A0F1200452EB78488AF7584CDBD486'::BYTEA) and case when (case when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x0000C222'::BYTEA then t5._fld104134rref when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x00000094'::BYTEA then t6._fld104132rref else cast(null as BYTEA) end is null) then FALSE else case when (case when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x0000C222'::BYTEA then t5._fld104134rref when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x00000094'::BYTEA then t6._fld104132rref else cast(null as BYTEA) end =  '\\xB37C9BC25ED146F8459F5CFCC5F8F4DA'::BYTEA) then 0x01 when not (case when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x0000C222'::BYTEA then t5._fld104134rref when t2._fld90294_type = '\\x08'::BYTEA and t2._fld90294_rtref = '\\x00000094'::BYTEA then t6._fld104132rref else cast(null as BYTEA) end =  '\\xB37C9BC25ED146F8459F5CFCC5F8F4DA'::BYTEA) then FALSE end end = TRUE) then FALSE 
				// Нельзя в большем кейсе заменить одинаково всречающиеся then 0x01, т.к. один может относиться к when, а второй к другой части
				// Поэтому пройдем по уже вставленным строкам и если у них длина меньше чем у текущей попробуем выполнить замену и только после этого обработаем оставшиеся then 0x01 
				ДлинаСтроки = СтрДлина(ПодстрокаПоиска);
				Для каждого СтрокаЗамен Из ТаблицаЗамен Цикл
					Если СтрокаЗамен.ДлинаСтроки < ДлинаСтроки Тогда
						ПодстрокаПоиска = СтрЗаменить(ПодстрокаПоиска, СтрокаЗамен.ПодстрокаПоиска, СтрокаЗамен.ПодстрокаЗамены);
					КонецЕсли;	
				КонецЦикла;
				
				
				// Ищем смежные c текущим tnen или else, выражения в которых позволят опредеделить на что нужно заменять
				Заменили = Ложь;
				ЭтоБулево = Ложь;
				
				// Ищем в 2 этапа. На первом этап обходим выразения только смежные с текущим tnen или else, на втором этапе идем по вложенным кейсам которые идут после смежных с текущим tnen else и в их блоках tnen else смотрим выражения
				Для Этап = 1 По 2 Цикл
					
					Если Заменили Тогда
						Прервать;
					КонецЕсли;   
					
					Для Инд = ИндCASE + 1 По ИндEND - 1 Цикл
						
						// Если это не вложенный сейс, то можем смотреть по его выражению
						Если 	ТаблицаCase[Инд - 1].Оператор <> НастройкаТестовКлиентСервер.Шаблон0x01вCase() 
								И ТаблицаCase[Инд + 1].Оператор <> "\bcase\swhen\b" 
								И ТаблицаCase[Инд].Оператор = "\b(then|else)\b"
								И (		Этап = 1 
										И ТаблицаCase[Инд].НомерCase = ТаблицаCase[Инд0x01].НомерCase
									ИЛИ Этап = 2 
										И ТаблицаCase[Инд].НомерCase > ТаблицаCase[Инд0x01].НомерCase
										И ТаблицаCase[Родители.Получить(ТаблицаCase[Инд].НомерCase)].Оператор = "\b(then|else)\b"
										И ТаблицаCase[ТаблицаCase[Инд].ИндРодителя].Оператор = "\b(then|else)\b"
									)
								Тогда 
								
							Подстрока = Сред(Результат, ТаблицаCase[Инд].НачальнаяПозиция, ТаблицаCase[Инд + 1].НачальнаяПозиция - ТаблицаCase[Инд].НачальнаяПозиция + 1);
							
							Для каждого Шаблон Из ШаблоныБайти Цикл
								Если СтрНайтиПоРегулярномуВыражению(Подстрока, Шаблон).НачальнаяПозиция > 0 Тогда
									Заменили = Истина;
									Прервать;
								КонецЕсли;		
							КонецЦикла;
							
							Если Не Заменили Тогда
								Для каждого Шаблон Из ШаблоныTrue Цикл
									Если СтрНайтиПоРегулярномуВыражению(Подстрока, Шаблон).НачальнаяПозиция > 0 Тогда
										Заменили = Истина;
										ЭтоБулево = Истина;
										Прервать;
									КонецЕсли;		
								КонецЦикла; 
							КонецЕсли;
							
							Если Заменили Тогда
								Прервать;
							КонецЕсли;
							
						Иначе 
							
							Продолжить;     
	
						КонецЕсли;
						
					КонецЦикла; 
				КонецЦикла;
				
				// Если меняем, то фиксируем подстроку поиска и замены, если не меняем, то будм пробовать заменить по планам запроса ниже
				Если Заменили Тогда
					НоваяСтрока = ТаблицаЗамен.Добавить();
					НоваяСтрока.ПодстрокаПоиска = ПодстрокаПоиска;
					НоваяСтрока.ПодстрокаЗамены = СтрЗаменитьПоРегулярномуВыражению(ПодстрокаПоиска, НастройкаТестовКлиентСервер.Шаблон0x01вCase(), ?(ЭтоБулево,"$1TRUE", "$1'\\\\001'::BYTEA"));
					НоваяСтрока.ДлинаСтроки = ДлинаСтроки;
					НоваяСтрока.ИндCASE = ИндCASE;
					НоваяСтрока.ИндEND = ИндEND;
					НоваяСтрока.ЭтоБулево = ЭтоБулево;
				//Иначе
					//НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "В модуле НастройкаТестов_СозданиеЗапросов.ИсправитьОтдельныеБинари1ВТексте не смогли преобразовать все 0x01 расположенных внутри конструкция case...end. Нужна отладка");
					//НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"));
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		ТаблицаЗамен = Неопределено;
		
	КонецЕсли;

	Возврат ТаблицаЗамен;
		
КонецФункции

Функция ТипБинари1(Знач ИмяПоля) Экспорт 
	
	Если Прав(ИмяПоля, СтрДлина("_type")) = "_type" Тогда
		Результат = "BYTEA";
	Иначе
		Результат = "BOOLEAN";
	КонецЕсли;
	
	Возврат Результат;
		
КонецФункции 

Функция ИсправитьТипыДанных(СоответствиеТиповДанных, Знач ТекстЗапроса, ОдинТип = Ложь, Поле = "") Экспорт 
	
	
	//// Если Передано поле, то в ТекстЗапроса один тип
	//Если ЗначениеЗаполнено(Поле) Тогда
	//	
	//	//ТекстЗапроса = ИсправитьТипДанных(ТекстЗапроса, Строка, Поле);
	//
	Если ОдинТип Тогда
		
		Строки = СоответствиеТиповДанных.НайтиСтроки(Новый Структура("ТипMSSQL, Скобки", ТекстЗапроса, Ложь));
		Если Не ЗначениеЗаполнено(Строки) И СтрНайти(ТекстЗапроса, "(") > 0 Тогда
			Строки = СоответствиеТиповДанных.НайтиСтроки(Новый Структура("ТипMSSQL", Лев(ТекстЗапроса, СтрНайти(ТекстЗапроса, "(") - 1)));
		КонецЕсли;
		
	Иначе
		//Если это общее исправление, то заменим разложение NULL
		ТекстЗапроса = СтрЗаменитьПоРегулярномуВыражению(
			ТекстЗапроса, 
			//"cast\(null as binary\(1\)\)(,\s*)cast\(null as binary\(1\)\),\s*cast\(null as NUMERIC\(38,\s*8\)\),\s*cast\(null as datetime\),\s*cast\(null as nvarchar\),\s*cast\(null as varbinary\),\s*cast\(null as binary\(4\)\),\s*cast\(null as binary\(16\)\)", 
			"cast\(null as binary\(1\)\)(,\s*)cast\(null as binary\(1\)\),\s*cast\(null as NUMERIC\(38,\s*8\)\),\s*cast\(null as datetime\),\s*cast\(null as nvarchar\),\s*cast\(null as binary\),\s*cast\(null as binary\(4\)\),\s*cast\(null as binary\(16\)\)", 
			"CAST(NULL AS BYTEA)$1CAST(NULL AS BOOLEAN)$1CAST(NULL AS NUMERIC)$1CAST(NULL AS TIMESTAMP)$1CAST(NULL AS MVARCHAR(1))$1CAST(NULL AS BYTEA)$1CAST(NULL AS BYTEA)$1CAST(NULL AS BYTEA)");
		
		Строки = СоответствиеТиповДанных;
		
	КонецЕсли;
	
	Для каждого Строка Из Строки Цикл
		
		ТекстЗапроса = ИсправитьТипДанных(ТекстЗапроса, Строка);		
			
	КонецЦикла;
	
	Возврат ТекстЗапроса;
		
КонецФункции 

Функция ИсправитьТипДанных(Знач ТекстЗапроса, Строка, Поле = "")
	
	// Если Поле не переадно, то это весь текст запроса или его большой кусок. В этом случае будем искать все вхождения типов и левее от них определять поля
	ПодстрокаПоиска = СтрШаблон("%1%2", Строка.ТипMSSQL, ?(Строка.Скобки, "(", "")); 
	
	Если Строка.Скобки Тогда
		
		Пока Истина Цикл
				
			ПозНач = СтрНайти(ТекстЗапроса, ПодстрокаПоиска);
			Если ПозНач = 0 Тогда
				Прервать;	
			КонецЕсли;   
			ПозКон = СтрНайти(ТекстЗапроса,")",,ПозНач);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Сред(ТекстЗапроса, ПозНач, ПозКон - ПозНач + 1), Строка.ТипPG);
			
		КонецЦикла;
		
	Иначе
		
		// Если это многострадальный binary(1), то опять возможны нюансы - это может быть и BYTEA и BOOLEAN - поэтому уберем явные boolean, а остатки скинем на bytea
		Если ПодстрокаПоиска = "binary(1)" Тогда
			ТекстЗапроса = СтрЗаменитьПоРегулярномуВыражению(ТекстЗапроса, "\b(then t\d+\.[a-z0-9_]{5,18}(?!_type)\)* else cast\(null as )(binary\(1\))(\)* (end|when))\b", "$1BOOLEAN$3", Ложь, Ложь); //  Переменная не должна заканчиваться на _type then t23.fld81283_type else cast(null as binary(1)) end
			ТекстЗапроса = СтрЗаменитьПоРегулярномуВыражению(ТекстЗапроса, "(\bcast\(null as )binary\(1\)(\) as [\w]{11}(?!_type))", "$1BOOLEAN$2", Ложь, Ложь); //  Переменная не должна заканчиваться на _type cast(null as binary(1)) as q_001_f_007_l,
		КонецЕсли;
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ПодстрокаПоиска, Строка.ТипPG);
		
	КонецЕсли;
	
	Возврат ТекстЗапроса;
		
КонецФункции 

// Исправление бинарных строк вида 0x..... кроме 0x01 в тексте запроса
Функция ИсправитьБинарнойСтрокиНаBytea(Знач Результат) Экспорт 
	
	// Вначале заменим 0x00 на FALSE
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\b0x00\b", "FALSE"); 
	
	// Заменим бинарные строки кроме 0x01, т.к. нужно перевести в верхний регистр, то будем делать через поиск
	//Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\b0x([\da-f]+)\b(?<!0x01)", "'\\\\x$1'::BYTEA");
	Пока Истина Цикл
		
		РезультатПоиска = СтрНайтиПоРегулярномуВыражению(Результат, "\b0x([\da-f]*)\b(?<!0x01)");
		Если РезультатПоиска.НачальнаяПозиция = 0 Тогда
			Прервать;	
		КонецЕсли;   
		
		Результат = НастройкаТестовКлиентСервер.ВыполнитьОдиночнуюЗамену(Результат, РезультатПоиска.НачальнаяПозиция, РезультатПоиска.Значение, СтрШаблон("'\\x%1'::BYTEA", ВРег(РезультатПоиска.ПолучитьГруппы()[0].Значение)));
		
	КонецЦикла;
	
	Возврат Результат;
		
КонецФункции

// Для событий rpc_completed, если запрос в виде exec sp_executesql n', где в тектсе запроса идут параметры, а значения представлены в отдельном блоке. Заменяет параметры в запросе на из значения 
Функция ЗаменитьПараметрыВЗапросе(СтрокаТаблицы, Знач ТекстЗапроса, ДопТаблицы)
	
	Если СтрНайти(ТекстЗапроса, "exec sp_executesql n'") > 0 Тогда
		
		// Вычленяем текст запроса
		Запрос = НастройкаТестовСервер.ТекстЗапросаMSSQL(ТекстЗапроса);
		
		// Вычленяем текст параметры 
		ПозНач = СтрДлина("exec sp_executesql n'") + 1;
		ПозКон = СтрНайти(ТекстЗапроса,"',n'",,ПозНач,1);
		ПозНач = ПозКон + 3;
		ПозКон = СтрНайти(ТекстЗапроса,"',",,ПозНач,1);
		Текст = Сред(ТекстЗапроса, ПозНач, ПозКон - ПозНач); 
		Текст = СтрЗаменить(Текст, "'", "");
		Текст = СтрЗаменить(Текст, ",@p", ";;@p");
		Парам = СтрРазделить(Текст, ";;", Ложь);
		
		// Вычленяем текст с значениями параметров
		Текст = Прав(ТекстЗапроса, СтрДлина(ТекстЗапроса) - ПозКон - 1);
		
		// Нельзя получить значения параметров просто разделив строку на ",", т.к. там могут быть конструкции в фигурных скобках у которых внутри "," типа:
		// '\\x813A00155D90360311E91888C47BE4ED'::bytea,63838059016948,5345,'4023-12-13 10:00:00',4.777,1,n'{"инфкл":"тонкийклиент","платф":"8.3.22.1851","конф":"1с:erp управление предприятием 2","конфвер":"2.5.12.1351","разд":[0]}','4023-12-13 10:10:42',63838059021725,n'жмурченко галина владимировна','4023-12-13 13:10:42',FALSE
		//ЗначенияПараметров = СтрРазделить(Текст, ",", Ложь);
		
		МассивСтроковыхПараметров(СтрокаТаблицы, Текст);
		ПланЗапросов.ЗаменитьСтроковыеЗначенияНаПараметры(Текст, СтрокаТаблицы.СтроковыеПараметры, "##str##", "n");
		
		ЗначенияПараметров = СтрРазделить(Текст, ",", Ложь);
		
		Если ЗначенияПараметров.Количество() <> Парам.Количество() Тогда
			
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Поймали ситуацию, когда В модуле НастройкаТестов_СозданиеЗапросов.ЗаменитьПараметрыВЗапросе некорректно выполнен разбор параметров из запроса MS SQL. Нужна отладка");
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"),,ДопТаблицы.Многопоточность);
			
			Возврат ТекстЗапроса;
				
		КонецЕсли;
		
		Для Сч = 0 По Парам.ВГраница() Цикл
			
			//ПодПараметры = СтрРазделить(Парам[Парам.Количество()- 1 - Сч], " ");
			ПодПараметры = РазделитьПолеСТипом(Парам[Парам.ВГраница() - Сч], ДопТаблицы.СоответствиеТиповДанных);
			ЗначениеПараметра = ЗначенияПараметров[Парам.ВГраница() - Сч];
			
			// Если в параметрах 0x01, то просто переносим в текст запроса, скорее всего это вставка в ВТ, затем по имени поля определим, что это за параметр
			Если 	ЗначениеПараметра = "0x01"
					Или ЗначениеПараметра = "FALSE" Тогда  
					
				Значение = ЗначениеПараметра;
				
			Иначе
				
				//Если Лев(ЗначениеПараметра, 11) = "##str_param" Тогда
				//	Значение = ЗначениеПараметра;
				//Иначе
					Тип = ИсправитьТипыДанных(ДопТаблицы.СоответствиеТиповДанных, ПодПараметры[1], Истина);
					Значение = ИсправитьЗначение(ЗначениеПараметра, Тип, Истина); 
				//КонецЕсли;
				
			КонецЕсли;
			
			Запрос = СтрЗаменить(Запрос, ПодПараметры[0], " " + Значение);
			
		КонецЦикла; 
		
		
	Иначе
		
		Запрос = ТекстЗапроса;
		
	КонецЕсли;
	
	// Перед исправлением строк в оставшемся запросе нужно избавиться от двойных кавычек, которые не строки иначе может некорректро отработать МассивСтроковыхПараметров
	Запрос = СтрЗаменитьПоРегулярномуВыражению(Запрос, "\s*\bescape\s+''(\/|\\)''", "", Ложь, Ложь); // Убрать конструкцию вида escape ''/'' или escape ''\'' - она не нужна 
	Запрос = СтрЗаменитьПоРегулярномуВыражению(Запрос, "\{ts '+(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})'+\}", "'$1'::TIMESTAMP", Ложь, Ложь);// t2._period >= {ts ''4018-01-01 00:00:00''}. Заменяет на t2._period >= '2018-01-01 00:00:00'::TIMESTAMP
	
	//Запрос = СтрЗаменитьПоРегулярномуВыражению(Запрос, "\bn''''(\s|\z|,)", "n''::mvarchar$1", Ложь, Ложь);// Заменяем пустые строки с парные кавычки
	
	// Если остались строки, то нужно и их переделать
	Если СтрНайти(Запрос, "n'") > 0 Тогда
		
		МассивСтроковыхПараметров(СтрокаТаблицы, Запрос);
		ПланЗапросов.ЗаменитьСтроковыеЗначенияНаПараметры(Запрос, СтрокаТаблицы.СтроковыеПараметры, "##str##", "n");
		
	КонецЕсли;
	
	Если СтрНайти(Запрос, "n'") > 0 Тогда
		
		НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Поймали ситуацию, когда В модуле НастройкаТестов_СозданиеЗапросов после замены параметров остались строки в запросе. Нужна отладка");
		НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"),,ДопТаблицы.Многопоточность);
		
	КонецЕсли;

	Возврат Запрос;
	
КонецФункции

// Изменяет значение по известному типу
Функция ИсправитьЗначение(Знач ЗначениеПараметра, Знач Тип, УбиратьТекстовыеТипы = Ложь) Экспорт 

	//Если Лев(ЗначениеПараметра, 2) = "n'" Тогда
	//	
	//	Результат = СтрЗаменить(ЗначениеПараметра, "n'", "'");
	
	// Закоментил, потом заменю 4 на 2 разом в ИсправитьФункции
	//Если Тип = "TIMESTAMP" Тогда
	//	
	//	// Не знаю, нафига так делал, просто переделаю с 4 на 2
	//	//Год = Число(Сред(ЗначениеПараметра, 2, 4)) - 2000;
	//	//Результат = СтрЗаменить(ЗначениеПараметра, Сред(ЗначениеПараметра, 2, 4), Формат(Год, "ЧГ=0"));
	//	Если Сред(ЗначениеПараметра, 2, 1) = "4" Тогда
	//		Результат = СтрШаблон("'2%1", Лев(ЗначениеПараметра, СтрДлина(ЗначениеПараметра) - 2));
	//	Иначе
	//		Результат = ЗначениеПараметра;
	//	КонецЕсли;		
	//	
	////ИначеЕсли Лев(ЗначениеПараметра, 2) = "0x" Тогда
	////	
	////	Результат = СтрЗаменить(ЗначениеПараметра, "0x", "\\x");
	////	
	//Иначе
		
		Результат = ЗначениеПараметра;
		
	//КонецЕсли;
	
	//Если Лев(ЗначениеПараметра, 2) = "0x" Тогда
	//	Результат = СтрШаблон("'%1'", Результат);
	//КонецЕсли;
	
	Если 	ЗначениеЗаполнено(Тип) 
			И СтрНайти(Результат, "::") = 0 Тогда
			
		Если УбиратьТекстовыеТипы Тогда
			ТипБезСкобки = СтрНайтиПоРегулярномуВыражению(Тип, "(\w+)\(?").ПолучитьГруппы()[0].Значение;	
		КонецЕсли;                                                                                      
		
		Если Не УбиратьТекстовыеТипы Или (ТипБезСкобки <> "TEXT") Тогда // И ТипБезСкобки <> "MVARCHAR") Тогда Закоментил иначе ошибка в событии 41354 - когда через юнион объединяется строка без типа (определяется как TEXT) и строка с типом mvarchar ограниченная
			Результат = СтрШаблон("%1::%2",Результат, Тип);
		КонецЕсли;
		
	КонецЕсли;
		
	Возврат Результат
	
КонецФункции

// Переделывает функции из Текста запроса с формат MSSQL на POstgres
Функция ИсправитьФункции(СтрокаТаблицы, Знач ТекстЗапроса, ДопТаблицы) Экспорт 
	
	Результат = ТекстЗапроса;
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\boption\s+\(fast\s+\d+\)", "", Ложь, Ложь); // Убрать конструкцию вида option (fast 1) - она не нужна
	
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\+(\s*\(*##str##\d+##str##)", "||$1", Ложь, Ложь); //  +  (##str##125##str## 
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(##str##\d+##str##\)*\s+)\+", "$1||", Ложь, Ложь); //    ##str##125##str##) + 
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\.[a-z0-9_]{4,12}_type\)*\s*)\+", "$1||", Ложь, Ложь);// COALESCE(t1._q_000_f_008_type + t1._q_000_f_008_rtref,'\\x0000000000'::BYTEA). Заменяет + на ||
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\+(\s*##str##\d+##str##::MVARCHAR)", "||$1", Ложь, Ложь);// Замена + на || -  +  ##str##2##str##::MVARCHAR
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(::MVARCHAR(\(\d+\))?\)*\s*(end\)*\s*)*)\+", "$1||", Ложь, Ложь);// Замена + на || -  ##str##2##str##::MVARCHAR(4000))) + или ::MVARCHAR(4000) end) end))) end + 
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "((\bBYTEA|rtref)\)*\s+(end)?\)*\s*)\+", "$1||", Ложь, Ложь);// (('\\x08'::BYTEA + t1._recordertref ИЛИ '\\x08'::BYTEA end + t1._q_001_f_001tre ИЛИ t1._q_001_f_001_rtref + t1._q_001_f_001_rrref. Заменяет + на ||
	// Считаю, что если в строке есть только цифры, буквы, точки, пробелы и скобки и || то можно заменить + на ||
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "(\|\|[\w\d \.\(\)]+)\+", "$1||", Ложь, Ложь);// Если в текущей строке состоящей из скобок, пробелов, букв и цифр нет запятых и есть ||, то заменяем + на || - || t1._fld44592) +
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\+([\w\d \.\(\)]+\|\|)", "||$1", Ложь, Ложь);// Обратный предыдущему пример, когда вначале идет +, а дальше - + t1._fld44592) ||
	
	
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\bTIMESTAMP2fromparts\((datepart\(\w+\s*,\s*((min|max)\()?[\w\d\.\_]+\){1,2}|\d{4}),(datepart\(\w+\s*,\s*((min|max)\()?[\w\d\.\_]+\){1,2}|\d{1,2}),(datepart\(\w+\s*,\s*((min|max)\()?[\w\d\.\_]+\){1,2}|\d{1,2}),(datepart\(\w+\s*,\s*((min|max)\()?[\w\d\.\_]+\){1,2}|\d{1,2}),(datepart\(\w+\s*,\s*((min|max)\()?[\w\d\.\_]+\){1,2}|\d{1,2}),(datepart\(\w+\s*,\s*((min|max)\()?[\w\d\.\_]+\){1,2}|\d{1,2}),(datepart\(\w+\s*,\s*((min|max)\()?[\w\d\.\_]+\){1,2}|\d{1,2}),(\d{1,3})\)", "make_timestamp($1,$4,$7,$10,$13,$16)", Ложь, Ложь);// TIMESTAMP2fromparts(datepart(year,t1._period),datepart(month,t1._period)
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\bdatepart\((year|month|day|hour|minute|second),(\s*[\w\d\.\_]+)\)", "EXTRACT($1 FROM $2)::int", Ложь, Ложь);// datepart(year,t1._period),datepart(month,t1._period)
	
	Результат = СтрЗаменить(Результат, "2001-01-01 00:00:00", "0001-01-01 00:00:00"); // Пустая дата с учетом смещения	
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "'4(\d{3}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}')", "'2$1", Ложь, Ложь);// '4023-11-26 00:00:00'::TIMESTAMP - исправление первой цифры с 4 на 2
	Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, "\b(and )?t(\d)*\._version\s*<>\s*'\\\\x[0-9A-F]{16}'::BYTEA\b", "", Ложь, Ложь);// убрать конструкцию and t2._version <>  '\\x0000000001AC801C'::BYTEA - непонятное сравнение на версию в SQL у _version - тип timestamp, а в PG - integer и в PG выдает ошибку, а в SQL нет, видать не сравнивает типы если <>
	
	Результат = СтрЗаменить(Результат, "isnull(", "COALESCE(");	
	Результат = СтрЗаменить(Результат, "count_big(", "COUNT(");

	// Исправление функции SUBSTRING(T1._Fld2853, CAST(@P6 AS INT), CAST(@P7 AS INT))
	// К сожалению в третьем параметре может быть скобки, а нужно искать закрывающую скобку функции. С помощью регвыражения это не получиться 
	// Поэтому регвыражениями обрабатываем только первые 2 параметра
	РезПоиска = СтрНайтиВсеПоРегулярномуВыражению(Результат, "(\bsubstring\([^,]+),([^,]+),");
	ДанныеЗамены = Новый Массив;
	Для Инд = 0 По РезПоиска.ВГраница() Цикл
		
		Рез = РезПоиска[РезПоиска.ВГраница() - Инд];
		Поз = Рез.НачальнаяПозиция + Рез.Длина;
		СчСкобки = 1;
		// Ищем закрывающую скобку
		Пока Истина Цикл 
			
			Если Сред(Результат, Поз, 1) = ")" Тогда
				СчСкобки = СчСкобки - 1;
				Если СчСкобки = 0 Тогда
					Прервать;	
				КонецЕсли;	
			ИначеЕсли Сред(Результат, Поз, 1) = "(" Тогда
				СчСкобки = СчСкобки + 1;
			КонецЕсли;
			
			Поз = Поз + 1;
			
		КонецЦикла;
		
		ТретийПараметр = Сред(Результат, Рез.НачальнаяПозиция + Рез.Длина, Поз - (Рез.НачальнаяПозиция + Рез.Длина) + 1);
		ПодстрокаПоиска = Рез.Значение + ТретийПараметр;
		
		ЕстьЗамена = Ложь;
		Для каждого Замена Из ДанныеЗамены Цикл
			Если Замена.ПодстрокаПоиска = ПодстрокаПоиска Тогда
				ЕстьЗамена = Истина;
				Прервать;	
			КонецЕсли;	
		КонецЦикла;
		
		Если Не ЕстьЗамена Тогда
			
			Замена = Новый Структура;
			Замена.Вставить("ПодстрокаПоиска", ПодстрокаПоиска);
			
			ПодстрокаЗамены = Рез.ПолучитьГруппы()[0].Значение;
			Если ВРЕГ(Прав(ПодстрокаЗамены, СтрДлина("::TEXT"))) <> "::TEXT" Тогда
				ПодстрокаЗамены	= СтрШаблон("%1::TEXT", ПодстрокаЗамены);
			КонецЕсли;
			ПодстрокаЗамены	= СтрШаблон("%1 FROM %2 FOR %3::MVARCHAR", ПодстрокаЗамены, Рез.ПолучитьГруппы()[1].Значение, ТретийПараметр);
			Замена.Вставить("ПодстрокаЗамены", ПодстрокаЗамены);
			
			ДанныеЗамены.Добавить(Замена);
			
		КонецЕсли;
		
	КонецЦикла; 
	
	Для каждого Замена Из ДанныеЗамены Цикл
		Результат = СтрЗаменить(Результат, Замена.ПодстрокаПоиска, Замена.ПодстрокаЗамены);	
	КонецЦикла;
	
	//Исправление функции DateAdd(datepart, count, dt). Переделывываем на конструкцию dt + (count * interval '1 datepart')
	//Переделвывает ее в цикле, ищем с конца, т.к. эти функции могу входить друг в друга:
	//dateadd(second, 59::NUMERIC(10),
	//    dateadd(minute, 59::NUMERIC(10),
	//        dateadd(hour, 23::NUMERIC(10),
	//            dateadd(day,cast(EXTRACT(day FROM t1._q_000_f_000) as NUMERIC(4)) - 1,dateadd(month,cast(EXTRACT(month FROM t1._q_000_f_000) as NUMERIC(4)) - 1,dateadd(year,(cast(EXTRACT(year FROM t1._q_000_f_000) as NUMERIC(4)) - 2000) - 2000, 
	//'4000-01-01 00:00:00'::TIMESTAMP))
	//            )
	//        )
	//    )
	//)
	// Поиск сложный, т.к. внутри могут быть и скобки и лишние запятые. Цель определить параметры, разделенные запятыми. Эти запятыые не должны быть во вложенных скобках
	Пока Истина Цикл
		
		ДанныеФункции = НастройкаТестовСервер.ПолучитьПараметрыФункции("dateadd", Результат);
		Если Не ЗначениеЗаполнено(ДанныеФункции) Тогда
			Прервать;	
		КонецЕсли;   
		
		Если ДанныеФункции.Параметры.Количество() <> 3 Тогда
			
			ТекстОшибки = СтрШаблон("Поймали ситуацию, когда функция НастройкаТестовСервер.ПолучитьПараметрыФункции неотработал возврат трех параметров: %1. Нужна отладка", ДанныеФункции.Текст);
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, ТекстОшибки);
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"),,ДопТаблицы.Многопоточность);
			Прервать;
			
		КонецЕсли;
		
		ТекстЗамены = СтрШаблон("%1 + (%2 * interval '1 %3')", ДанныеФункции.Параметры[3].Текст, ДанныеФункции.Параметры[2].Текст, ДанныеФункции.Параметры[1].Текст);
		Результат = СтрЗаменить(Результат, ДанныеФункции.Текст, ТекстЗамены);
		
	КонецЦикла; 
	
	// Исправление функции datediff(datepart,dt1,dt2). Переделываем на SELECT EXTRACT(epoch FROM dt2 - dt1) / Количество секунд в datepart
	Пока Истина Цикл
		
		ДанныеФункции = НастройкаТестовСервер.ПолучитьПараметрыФункции("datediff", Результат);
		Если Не ЗначениеЗаполнено(ДанныеФункции) Тогда
			Прервать;	
		КонецЕсли;   
		
		Если ДанныеФункции.Параметры.Количество() <> 3 Тогда
			
			ТекстОшибки = СтрШаблон("Поймали ситуацию, когда функция НастройкаТестовСервер.ПолучитьПараметрыФункции неотработал возврат трех параметров: %1. Нужна отладка", ДанныеФункции.Текст);
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, ТекстОшибки);
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"),,ДопТаблицы.Многопоточность);
			Прервать;
			
		КонецЕсли;
		
		// Разные варианты вычисления разницы в различных частях, с учетом и без учета age
		//SELECT age('2036-05-01 01:10:00'::TIMESTAMP, '2025-02-27 00:00:00'::TIMESTAMP) = "11 years 2 mons 2 days 01:10:00"
		//SELECT '2036-05-01 01:10:00'::TIMESTAMP - '2025-02-27 00:00:00'::TIMESTAMP = "4081 days 01:10:00"

		//SELECT EXTRACT(epoch FROM '2036-05-01 01:10:00'::TIMESTAMP - '2025-02-27 00:00:00'::TIMESTAMP) = 352602600.000000
		//SELECT EXTRACT(year FROM age('2036-05-01 01:10:00'::TIMESTAMP, '2025-02-27 00:00:00'::TIMESTAMP)) = 11
		//SELECT EXTRACT(year FROM '2036-05-01 01:10:00'::TIMESTAMP - '2025-02-27 00:00:00'::TIMESTAMP) = 0
		//SELECT EXTRACT(day FROM age('2036-05-01 01:10:00'::TIMESTAMP, '2025-02-27 00:00:00'::TIMESTAMP)) = 2
		//SELECT EXTRACT(day FROM '2036-05-01 01:10:00'::TIMESTAMP - '2025-02-27 00:00:00'::TIMESTAMP) = 4081
		//SELECT EXTRACT(hour FROM '2036-05-01 01:10:00'::TIMESTAMP - '2025-02-27 00:00:00'::TIMESTAMP) = 1
		//SELECT EXTRACT(hour FROM age('2036-05-01 01:10:00'::TIMESTAMP, '2025-02-27 00:00:00'::TIMESTAMP)) = 1	
		
		// Учел, что datediff возвращает не разность дат, а пересечение границ, например: Разница между аргументами startdate и enddate в каждой инструкции пересекает одну календарную или временную границу аргумента datepart. Каждое выражение возвращает значение 1.
		//SELECT DATEDIFF(year,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(quarter,     '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(month,       '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(dayofyear,   '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(day,         '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(week,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(weekday,     '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(hour,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(minute,      '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(second,      '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(millisecond, '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		//SELECT DATEDIFF(microsecond, '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
		
		// Получается все что меньше или равно DAY можно вычислять через SELECT EXTRACT(epoch FROM и разделить на соотвтествующий коэффициент
		// Соответственно я использовал не даты, брал даты на начало соответствующего периода с помощью функции date_trunc, в этом случае деление на коэффициент всегда целое и правильный результат
		Если 	ДанныеФункции.Параметры[1].Текст = "day" 
				ИЛИ ДанныеФункции.Параметры[1].Текст = "hour" 
				ИЛИ ДанныеФункции.Параметры[1].Текст = "minute" Тогда
				
			Если ДанныеФункции.Параметры[1].Текст = "day" Тогда
				Коэф = "86400";
			ИначеЕсли ДанныеФункции.Параметры[1].Текст = "hour" Тогда
				Коэф = "3600";
			ИначеЕсли ДанныеФункции.Параметры[1].Текст = "minute" Тогда
				Коэф = "60";
			КонецЕсли;
			
			ТекстЗамены = СтрШаблон("EXTRACT(epoch FROM date_trunc('%1', %2) - date_trunc('%1',%3)) / %4", ДанныеФункции.Параметры[1].Текст, ДанныеФункции.Параметры[3].Текст, ДанныеФункции.Параметры[2].Текст, Коэф); 
			
		ИначеЕсли ДанныеФункции.Параметры[1].Текст = "second" Тогда
			
			ТекстЗамены = СтрШаблон("EXTRACT(epoch FROM %2 - %3)", ДанныеФункции.Параметры[1].Текст, ДанныеФункции.Параметры[3].Текст, ДанныеФункции.Параметры[2].Текст); 
			
		// Для месяцев и лет будем получать через SELECT EXTRACT(year FROM age( - для месяцев суммируя по годам * 12 + по месяцам. 
		ИначеЕсли ДанныеФункции.Параметры[1].Текст = "year" Тогда
			
			ТекстЗамены = СтрШаблон("EXTRACT(year FROM age(date_trunc('year', %1), date_trunc('year', %2)))", ДанныеФункции.Параметры[3].Текст, ДанныеФункции.Параметры[2].Текст);
			
		ИначеЕсли ДанныеФункции.Параметры[1].Текст = "month" Тогда
			
			ТекстЗамены = СтрШаблон("EXTRACT(year FROM age(date_trunc('month', %1), date_trunc('month', %2))) * 12 + EXTRACT(month FROM age(date_trunc('month', %1), date_trunc('month', %2)))", ДанныеФункции.Параметры[3].Текст, ДанныеФункции.Параметры[2].Текст);
			
		Иначе
			
			ТекстОшибки = СтрШаблон("Поймали ситуацию, когда при преобразовании функции datediff не преобразовали часть даты '%1' : %2. Нужно добавить поддержку этой части даты",  ДанныеФункции.Параметры[1].Текст, ДанныеФункции.Текст);
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, ТекстОшибки);
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"),,ДопТаблицы.Многопоточность);
			Прервать;
				
		КонецЕсли;
		
		Результат = СтрЗаменить(Результат, ДанныеФункции.Текст, ТекстЗамены);
			
	КонецЦикла;
	
	Возврат Результат
	
КонецФункции

Процедура СообщитьОбОшибкахОтладки(НастройкаТеста, ИмяРеквизита) Экспорт 
	
	// Сообщение об отладке - возможности дописать код, для ислкючения ошибок
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Количество(*) КАК Количество   
	|ИЗ
	|	РегистрСведений.РезультатыВыполненияЗапросов
	|ГДЕ
	|	НастройкаТеста = &НастройкаТеста
	|	И ОшибкаПреобразования.ОтладкаСозданияВТ
	|";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ОтладкаСозданияВТ", ИмяРеквизита);
	Запрос.УстановитьПараметр("НастройкаТеста", НастройкаТеста);
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Если ЗначениеЗаполнено(Выборка.Количество) Тогда
		ОбщегоНазначения.СообщитьПользователю(СтрШаблон("При заполнении отмечено %1 тестовых ситуаций, которые не отработаны. Подробности в полях ""Текст ошибки"" строк с ошибкой преобразования %2. Возможно следует доработать код.", Выборка.Количество, ИмяРеквизита));
	КонецЕсли;	
		
КонецПроцедуры

// Устанавливает треумое значение Ошибки преобразования. Если он отсутствует, создает новый требуемый элемент
Процедура УстановитьОшибкуПреобразования(ОшибкиПреобразования, СтрокаТаблицы, ФлагДобавления = "", ФлагИсключения = "", Многопоточность = Ложь) Экспорт 
	
	Если ФлагДобавления = "" И ФлагИсключения = "" Тогда
		Возврат;	
	КонецЕсли;
	//Если Не ЗначениеЗаполнено(СтрокаТаблицы.ОшибкаПреобразования) И Не ЗначениеЗаполнено(ФлагДобавления) Тогда
	//	Возврат;	
	//КонецЕсли;  
	
	РеквизитыОшибки = НастройкаТестовСерверПовтИсп.РеквизитыОшибки();
	Если ЗначениеЗаполнено(СтрокаТаблицы.ОшибкаПреобразования) Тогда
		Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СтрокаТаблицы.ОшибкаПреобразования, РеквизитыОшибки.РеквизитыСтрокой); 
	Иначе
		Реквизиты = ОбщегоНазначения.СкопироватьРекурсивно(РеквизитыОшибки.СтруктураЛожь);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ФлагДобавления) Тогда
		Реквизиты[ФлагДобавления] = Истина;	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ФлагИсключения) Тогда
		Реквизиты[ФлагИсключения] = Ложь;	
	КонецЕсли; 
	
	Если ПустаяСтрока(ФлагДобавления) Тогда
		
		ЕстьИстина = Ложь;
		Для каждого КиЗ Из Реквизиты Цикл
			
			Если КиЗ.Значение Тогда
				
				ЕстьИстина = Истина;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если Не ЕстьИстина Тогда                              
			
			СтрокаТаблицы.ОшибкаПреобразования = Неопределено;
			СтрокаТаблицы.ВидОшибки = Неопределено;
			Возврат;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Строки = ОшибкиПреобразования.НайтиСтроки(Реквизиты);
	
	Если Строки.Количество() = 0 Тогда
		
		// Если работа в многопоточном режиме, то что бы избежать задваивания ошибок с одинаковыми флагами, котоыре могут быть созданы в других потоках
		// будем проверять запросом с блокировками
		Если Многопоточность Тогда
			
			НачатьТранзакцию();
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("Справочник.ОшибкиПреобразования");
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			//Для каждого КиЗ Из Реквизиты Цикл
			//	ЭлементБлокировки.УстановитьЗначение(КиЗ.Ключ, КиЗ.Значение);
			//КонецЦикла;
			Блокировка.Заблокировать(); 
			
			Запрос = Новый Запрос;
			Запрос.Текст = "
			|ВЫБРАТЬ ПЕРВЫЕ 1
			|	*   
			|ИЗ
			|	Справочник.ОшибкиПреобразования
			|ГДЕ
			|   НЕ ПометкаУдаления
			|	//%Отборы%
			|";
			
			Отборы = "";
			Для каждого КиЗ Из Реквизиты Цикл
				Отборы = СтрШаблон("%1%2И %3", Отборы, Символы.ПС, ?(КиЗ.Значение, "", "НЕ ") + КиЗ.Ключ);
			КонецЦикла;
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "//%Отборы%", Отборы);
			РезультатЗапроса = Запрос.Выполнить();
			
			Если Не РезультатЗапроса.Пустой() Тогда
				Выборка = РезультатЗапроса.Выбрать();
				Выборка.Следующий();
				ОшибкаПреобразования = Выборка.Ссылка;
			Иначе
				ОшибкаОбъект = Справочники.ОшибкиПреобразования.СоздатьЭлемент();
				ЗаполнитьЗначенияСвойств(ОшибкаОбъект, Реквизиты);
				ОшибкаОбъект.Записать();
				ОшибкаПреобразования = ОшибкаОбъект.Ссылка;
			КонецЕсли;
			ЗафиксироватьТранзакцию();
			
		Иначе
			
			ОшибкаОбъект = Справочники.ОшибкиПреобразования.СоздатьЭлемент();
			ЗаполнитьЗначенияСвойств(ОшибкаОбъект, Реквизиты);
			ОшибкаОбъект.Записать();
			ОшибкаПреобразования = ОшибкаОбъект.Ссылка;
			
		КонецЕсли;
		
		НоваяСтрока = ОшибкиПреобразования.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Реквизиты);
		НоваяСтрока.Ссылка = ОшибкаПреобразования;
		
	Иначе
		
		ОшибкаПреобразования = Строки[0].Ссылка;
		
	КонецЕсли;
	
	СтрокаТаблицы.ОшибкаПреобразования = ОшибкаПреобразования;
	СтрокаТаблицы.ВидОшибки = ПредопределенноеЗначение("Перечисление.ВидыОшибокЗапросов.ОшибкаПреобразования");

КонецПроцедуры

// Нельзя получить значения параметров просто разделив строку на ",", т.к. там могут быть сложные строки, внутри которых может быть все что угодно и ковычки и запятые и т.д. 
// '\\x813A00155D90360311E91888C47BE4ED'::bytea,63838059016948,5345,'4023-12-13 10:00:00',4.777,1,n'{"инфкл":"тонкийклиент","платф":"8.3.22.1851","конф":"1с:erp управление предприятием 2","конфвер":"2.5.12.1351","разд":[0]}','4023-12-13 10:10:42',63838059021725,n'жмурченко галина владимировна','4023-12-13 13:10:42',FALSE
// Поэтому строки будем хранить отдельно, а пока заменим строки на временные параметры
Процедура МассивСтроковыхПараметров(СтрокаТаблицы, Знач Текст) Экспорт  
	
	// Выкинем даты
	Текст = СтрЗаменитьПоРегулярномуВыражению(Текст, "(?<!n)'{1,2}\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}'{1,2}", "");
	
	// Выкинем бинарные строки
	Текст = СтрЗаменитьПоРегулярномуВыражению(Текст, "'\\\\x[\dA-F]*'::BYTEA", "BYTEA"); 
	
	// Ищем начала строк
	РезультатыПоиска = СтрНайтиВсеПоРегулярномуВыражению(Текст, ",?n(')");
	
	Если РезультатыПоиска.Количество() > 0 И СтрокаТаблицы.СтроковыеПараметры = Неопределено Тогда
		СтрокаТаблицы.СтроковыеПараметры = Новый Массив;
	КонецЕсли;
	
	Инд = 1;
	Для каждого РезультатПоиска Из РезультатыПоиска Цикл
		
		Если Инд = РезультатыПоиска.Количество() Тогда
			ПозКон = СтрДлина(Текст);
		Иначе
			ПозКон = РезультатыПоиска[Инд].НачальнаяПозиция;
		КонецЕсли;
		
		Инд = Инд + 1;
		
		// Ищем позицию закрывающей кавыки
		ПозицияЗакрывающейКавычки = СтрНайти(Текст, "'", НаправлениеПоиска.СКонца, ПозКон);
		СтроковыйПараметр = Сред(Текст, РезультатПоиска.ПолучитьГруппы()[0].НачальнаяПозиция, ПозицияЗакрывающейКавычки - РезультатПоиска.ПолучитьГруппы()[0].НачальнаяПозиция + 1); 
		
		Если СтрокаТаблицы.СтроковыеПараметры.Найти(СтроковыйПараметр) = Неопределено Тогда 
			//СтрокаТаблицы.СтроковыеПараметры.Добавить(СтроковыйПараметр);
			Сч = 0;
			Добавили = Ложь;
			Для каждого Рез Из СтрокаТаблицы.СтроковыеПараметры Цикл
				Если СтрДлина(СтроковыйПараметр) >= СтрДлина(Рез) Тогда
					СтрокаТаблицы.СтроковыеПараметры.Вставить(Сч, СтроковыйПараметр);
					Добавили = Истина;
					Прервать;
				КонецЕсли;	 
				Сч = СЧ + 1;
			КонецЦикла;              
			Если Не Добавили Тогда
				СтрокаТаблицы.СтроковыеПараметры.Добавить(СтроковыйПараметр);
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла; 
	
КонецПроцедуры

Функция ИсправитьОтдельныеБинари1ВТексте(СтрокаТаблицы, Знач Результат, ДопТаблицы) Экспорт 
	
	// Замена всех оставшихся отдельных полей 0x01 экранированных запятыми или началами и концами строк на TRUE
	Если СтрокаТаблицы.ПланЗапроса = Неопределено Тогда
		// В цикле, т.к. за один проход смежные 0x01 не заменяются
		//Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01(), "$1TRUE$6", Ложь, Ложь); 
		Шаблон = НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01();
		Пока Истина Цикл
			
			РезультатПоиска = СтрНайтиПоРегулярномуВыражению(Результат, Шаблон);
			Если РезультатПоиска.НачальнаяПозиция = 0 Тогда
				Прервать;	
			КонецЕсли;
			
			Результат = СтрЗаменитьПоРегулярномуВыражению(Результат, Шаблон, "$1TRUE$6", Ложь, Ложь);
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Если осталось еще 0x01, то выдаем ошибку
	Если СтрНайтиПоРегулярномуВыражению(Результат, "\b0x01\b").Длина > 0 Тогда
		
		НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "Ошибка преобразования 0x01");
		УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, "Преобразование0x01",,ДопТаблицы.Многопоточность);
		
	КонецЕсли; 
	
	Возврат Результат;

КонецФункции                                                                            

#Область Вспомогательные_таблицы

// Заполняет таблицу формы по соответствию типов данных в MSSQL и POstgres
Функция ЗаполнитьСоответствиеТиповДанных() Экспорт 
	
	//ПОРЯДОК СТРОК ВАЖЕН, ПОЭТОМУ НЕ СООТВЕТСТВИЕ, А ТАБЛИЦА!!!
	СоответствиеТиповДанных = Новый ТаблицаЗначений;
	СоответствиеТиповДанных.Колонки.Добавить("ТипMSSQL", Новый ОписаниеТипов("Строка", ,
														 Новый КвалификаторыСтроки(200, ДопустимаяДлина.Переменная)));
	СоответствиеТиповДанных.Колонки.Добавить("ТипPG", Новый ОписаниеТипов("Строка", ,
														 Новый КвалификаторыСтроки(200, ДопустимаяДлина.Переменная)));
	СоответствиеТиповДанных.Колонки.Добавить("Скобки", Новый ОписаниеТипов("Булево"));
	СоответствиеТиповДанных.Колонки.Добавить("ПостфиксПоля", Новый ОписаниеТипов("Строка", ,
															 Новый КвалификаторыСтроки(20, ДопустимаяДлина.Переменная)));
	//Замена NULL
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = СтрШаблон("cast(null as binary(1)),%1%2cast(null as binary(1)),%1%2cast(null as numeric(38,8)),%1%2cast(null as datetime),%1%2cast(null as nvarchar),%1%2cast(null as varbinary),%1%2cast(null as binary(4)),%1%2cast(null as binary(16))", Символ(13), Символ(10));
	//НоваяСтрока.ТипPG = СтрШаблон("CAST(NULL AS BYTEA),%1%2CAST(NULL AS BOOLEAN),%1%2CAST(NULL AS NUMERIC),%1%2CAST(NULL AS TIMESTAMP),%1%2CAST(NULL AS MVARCHAR(1)),%1%2CAST(NULL AS BYTEA),%1%2CAST(NULL AS BYTEA),%1%2CAST(NULL AS BYTEA)", Символ(13), Символ(10));
	
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = "nchar";
	//НоваяСтрока.ТипPG = "CHAR";
	//
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = "ntext";
	//НоваяСтрока.ТипPG = "TEXT";
	
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "nvarchar(max)";
	НоваяСтрока.ТипPG = "TEXT";
	
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "nvarchar(-1)";
	НоваяСтрока.ТипPG = "TEXT";
	
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "nvarchar";
	НоваяСтрока.ТипPG = "MVARCHAR";
	
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = "tinyint";
	//НоваяСтрока.ТипPG = "SMALLINT";
	//
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = "uniqueidentifier";
	//НоваяСтрока.ТипPG = "CHAR(16)";
	//
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = "varbinary(max)";
	//НоваяСтрока.ТипPG = "BYTEA";
	
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = "varchar(max)";
	//НоваяСтрока.ТипPG = "TEXT";
	
	// Замена типов у которых в скобках есть цифры
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "datetime2";
	НоваяСтрока.ТипPG = "TIMESTAMP";
	НоваяСтрока.Скобки = Истина;
	
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = "varbinary";
	//НоваяСтрока.ТипPG = "BYTEA";
	//НоваяСтрока.Скобки = Истина;
	
	//НоваяСтрока = СоответствиеТиповДанных.Добавить();
	//НоваяСтрока.ТипMSSQL = "varbinary";
	//НоваяСтрока.ТипPG = "BYTEA";
	
	// Если в имени поля есть постфикс _type, то этот бинари(1) есть байти
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "binary(1)";
	НоваяСтрока.ТипPG = "BYTEA";
	НоваяСтрока.ПостфиксПоля = "_type";
	
	// Все оставшиеся бинари(1) считаем булеаном
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "binary(1)";
	НоваяСтрока.ТипPG = "BOOLEAN";
	
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "binary";
	НоваяСтрока.ТипPG = "BYTEA";
	НоваяСтрока.Скобки = Истина;
	
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "binary";
	НоваяСтрока.ТипPG = "BYTEA";
	
	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "datetime";
	НоваяСтрока.ТипPG = "TIMESTAMP";

	НоваяСтрока = СоответствиеТиповДанных.Добавить();
	НоваяСтрока.ТипMSSQL = "nchar";
	НоваяСтрока.ТипPG = "MVARCHAR";
	
	Возврат СоответствиеТиповДанных;
	
КонецФункции

Функция ОшибкиПреобразования() Экспорт 
	
	// Кэш ошибок преобразования
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*   
	|ИЗ
	|	Справочник.ОшибкиПреобразования
	|ГДЕ 
	|	НЕ ПометкаУдаления
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	Результат = РезультатЗапроса.Выгрузить();

	Возврат Результат;
		
КонецФункции

#КонецОбласти

Процедура ЗаполнитьПланЗапроса(СтрокаТаблицы, Результат, ДопТаблицы)
	
	ЕстьОтдельноСтроящие0x01 = СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01()).Длина > 0; 
	// Если остались 0x01 в case после замены в ИсправитьБинари1ВТексте, то тоже попробуем определить по плану запроса
	Есть0x01ВCase = СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина > 0;
	ЕстьUnion = СтрНайтиПоРегулярномуВыражению(Результат, "\s+union\s+").Длина > 0;
	РезультатыСложныеTOP = СтрНайтиВсеПоРегулярномуВыражению(Результат, "\b(select(\s+distinct)?)\s+top\s+(\d+)\b"); 

	ЗаполняемПланЗапроса = Ложь;
	
	Если (Есть0x01ВCase Или ЕстьОтдельноСтроящие0x01) И ЕстьUnion Или РезультатыСложныеTOP.Количество() > 1 Или ЕстьUnion И РезультатыСложныеTOP.Количество() > 0 Тогда
		
		ЗаполняемПланЗапроса = Истина;
		
	ИначеЕсли СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы Тогда
		
		ИмяТаблицы = НастройкаТестов_СозданиеВременныхТаблиц.ИмяВТ(Результат, "insert into pg_temp.");
		ЕстьValues = СтрНайти(Результат, " values(") > 0;
		// Если вообще нет записей по текущей ВТ в РС ПоляВременныхТаблицыPostgres, то их нужно заполнить - получается, что текущее событие заполнения ВТ и есть создание ВТ, 
		// т.к. при последующем создании ВТ с тамик же имененм (при рестарте сервера 1С) Поля будут заполнены
		ЗаполняемПоляВременнойТаблицы = Не ЗначениеЗаполнено(НастройкаТестов_СозданиеВременныхТаблиц.ДанныеПолейВременнойТаблицы(ДопТаблицы.ПоляВременныхТаблицыPostgres, СтрокаТаблицы.НомерСессии, ИмяТаблицы)) И ЕстьValues;
		ЕстьВValues0x01 = ЕстьValues И СтрНайтиПоРегулярномуВыражению(Результат, "(values\(|,)\s*(0x01)\s*(\)|,)").Длина > 0; 
		ЗаполняемПланЗапроса = ЗаполняемПоляВременнойТаблицы Или ЕстьВValues0x01 Или ЕстьОтдельноСтроящие0x01 Или Есть0x01ВCase;

	КонецЕсли;
	
	Если ЗаполняемПланЗапроса Тогда
		
		СтрокаТаблицы.ПланЗапроса = ПланЗапросов.ПолучитьОбъектЗапроса(Результат, СтрокаТаблицы.СтроковыеПараметры);
		
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(СтрокаТаблицы.СтроковыеПараметры) Тогда
		
		ПланЗапросов.ЗаменитьПараметрыНаСтроковыеЗначения(Результат, СтрокаТаблицы.СтроковыеПараметры, "##str##"); // 20.02.2024 Берлизов Сергей. CE-Возвращаем на место строковые параметры
		
	КонецЕсли;
	
КонецПроцедуры

// Пробуем определить на что менять отдельно строящие 0x01 по имени поля в другом запросе через union
Функция ИсправитьОтдельныеБинари1ВОбычномЗапросе(СтрокаТаблицы, Знач Результат, ДопТаблицы) Экспорт 
	
	//ЕстьОтдельноСтроящие0x01 = СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01()).Длина > 0;  
	// Возможна ситуация, когда отдельностоящие 0x01 идут подряд через запятую. В этом случае НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01() 
	// Пропустит один 0x01, и уменьшит количество, поэтому для подсчета количества изменю текст запроса
	КоличествоОтдельноСтроящих0x01 = СтрНайтиВсеПоРегулярномуВыражению(СтрЗаменитьПоРегулярномуВыражению(Результат, "\b0x01,", "0x01,,"), НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01()).Количество(); 
	ЕстьUnion = СтрНайтиПоРегулярномуВыражению(Результат, "\s+union\s+").Длина > 0;
	// Если остались 0x01 в case после замены в ИсправитьБинари1ВТексте, то тоже попробуем определить по плану запроса
	Есть0x01ВCase = СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина > 0;

	Если КоличествоОтдельноСтроящих0x01 > 0 И ЕстьUnion Тогда
		
		Результат = ИсправитьОтдельныеБинари1ВОтдельномЗапросе(СтрокаТаблицы.ПланЗапроса.ЗапросИсточник, СтрокаТаблицы, Результат, КоличествоОтдельноСтроящих0x01, ДопТаблицы.ОшибкиПреобразования);
			
		Если КоличествоОтдельноСтроящих0x01 > 0 Тогда
			
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "В модуле НастройкаТестов_СозданиеЗапросов.ИсправитьОтдельныеБинари1ВОбычномЗапросе не смогли преобразовать все отдельностоящие 0x01. Нужна отладка");
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"),,ДопТаблицы.Многопоточность);
			
		КонецЕсли;
		
	КонецЕсли;

	Если Есть0x01ВCase > 0 И ЕстьUnion Тогда
		
		Результат = Исправить0x01ВCaseВОтдельномЗапросе(СтрокаТаблицы.ПланЗапроса.ЗапросИсточник, СтрокаТаблицы, Результат, ДопТаблицы.ОшибкиПреобразования);
			
		Если СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина > 0 > 0 Тогда
			
			НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, "В модуле НастройкаТестов_СозданиеЗапросов.ИсправитьОтдельныеБинари1ВОбычномЗапросе не смогли преобразовать все 0x01 в конструкциях CASE...END. Нужна отладка");
			НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ДопТаблицы.ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"),,ДопТаблицы.Многопоточность);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИсправитьОтдельныеБинари1ВОтдельномЗапросе(ЗапросИсточник, СтрокаТаблицы, Знач Результат, КоличествоОтдельноСтроящих0x01, ОшибкиПреобразования)

	ПодстрокаЗапроса = "\bselect\b";
	ПодстрокаПоиска = "0x01";
	Для каждого ПолеИсточник Из ЗапросИсточник Цикл
		
		ПозНач = СтрНайтиПоРегулярномуВыражению(Результат, ПодстрокаЗапроса,, , ПолеИсточник.НомерВыборки).НачальнаяПозиция;
		Пока Истина Цикл
			
			Инд = ПолеИсточник.МассивПолей.Найти(ПодстрокаПоиска);
			Если Инд = Неопределено Тогда
				Прервать;	
			КонецЕсли;
			
			// Определяем подстроку замены по данным полей в текущей позиции в смежных запросам
			ПодстрокаЗамены = ПодстрокаЗамены0x01(СтрокаТаблицы, ЗапросИсточник, Инд, ПодстрокаПоиска, ОшибкиПреобразования);
			
			ПолеИсточник.МассивПолей[Инд] = ПодстрокаЗамены;
			ПозНач = СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.ШаблонОтдельностоящих0x01(),,ПозНач).ПолучитьГруппы()[4].НачальнаяПозиция;
			// Т.к. подстрока с начала до найденного 0x01 может быть неуникальна в рамаках запроса будем заменять на подстроку с начала запроса до нужной позиции + ПодстрокаЗамены + Конец
			Результат = НастройкаТестовКлиентСервер.ВыполнитьОдиночнуюЗамену(Результат, ПозНач, ПодстрокаПоиска, ПодстрокаЗамены);
			
			КоличествоОтдельноСтроящих0x01 = КоличествоОтдельноСтроящих0x01 - 1;
			Если КоличествоОтдельноСтроящих0x01 = 0 Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЦикла;
		
		Если КоличествоОтдельноСтроящих0x01 = 0 Тогда
			Прервать;	
		КонецЕсли;
		
		Если ПолеИсточник.ОсновнаяТаблица <> Неопределено И ПолеИсточник.ОсновнаяТаблица.Запрос <> Неопределено Тогда
			
			Результат = ИсправитьОтдельныеБинари1ВОтдельномЗапросе(ПолеИсточник.ОсновнаяТаблица.Запрос.ЗапросИсточник, СтрокаТаблицы, Результат, КоличествоОтдельноСтроящих0x01, ОшибкиПреобразования);
			
			Если КоличествоОтдельноСтроящих0x01 = 0 Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
			
	Возврат Результат;
		
КонецФункции

Функция ПодстрокаЗамены0x01(СтрокаТаблицы, ЗапросИсточник, Инд, ПодстрокаПоиска, ОшибкиПреобразования)
	
	ПодстрокаЗамены = Неопределено;
	Для каждого ПолеИсточникаБис Из ЗапросИсточник Цикл
		
		Если ПолеИсточникаБис.МассивПолей[Инд] = ПодстрокаПоиска Тогда
			
			Продолжить;
			
		ИначеЕсли СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "(\b(then|else)\s+\(*\(*([a-z]\d{1,3}\.[a-z0-9_]{4,12}_type|'\\\\(x[0-9a-f]*|001)'::BYTEA)\)*\s+end\s*\z)").НачальнаяПозиция > 0 // then t1._q_000_f_005_type end ИЛИ then '\\x08'::BYTEA end
				Или СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "^\s*\(*\(*[a-z]\d{1,3}\.[a-z0-9_]{4,12}_type\)*\s*\z").НачальнаяПозиция > 0 // В строке только поле оканчивающееся на _type: t1._q_000_f_005_type 
				//ИЛИ СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "^\s*'\\\\(x[0-9a-f]*|001)'::BYTEA\s+as\s+").НачальнаяПозиция > 0 // '\\001'::BYTEA as 
				ИЛИ СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "\bas\s+[a-z0-9_]{12}type\s*\z").НачальнаяПозиция > 0 // as q_001_f_001_type
				ИЛИ СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "^\s*'\\\\(x[0-9a-f]*|001)'::BYTEA\s*\z").НачальнаяПозиция > 0 // '\\x08'::BYTEA
				Тогда
			
			ПодстрокаЗамены = "'\\001'::BYTEA";
			Прервать; 
			
		ИначеЕсли СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "^\s*(TRUE|FALSE)\s*\z").НачальнаяПозиция > 0 // TRUE или FALSE
				ИЛИ СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "(\b(then|else)\s+(TRUE|FALSE)\(*\)*\s+end\s*\z)").НачальнаяПозиция > 0 // then TRUE else FALSE end
				ИЛИ (СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "\bas\s+[a-z0-9_]{12,17}\s*\z").НачальнаяПозиция > 0 // По постиксу псевдонима - он должен быть без _type
						ИЛИ СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "^\s*\(*\(*[a-z]\d{1,3}\.[a-z0-9_]{4,12}\)*\s*\z").НачальнаяПозиция > 0
					) И СтрНайтиПоРегулярномуВыражению(ПолеИсточникаБис.МассивПолей[Инд], "_type\s*\z").НачальнаяПозиция = 0 
				Тогда
			
			ПодстрокаЗамены = "TRUE";
			Прервать;
			
		Иначе 
			
			ТаблицаЗамен = ТаблицаЗаменCase(ПолеИсточникаБис.МассивПолей[Инд], Ложь);
			Если ЗначениеЗаполнено(ТаблицаЗамен) Тогда
				
				ПодстрокаЗамены = ?(ТаблицаЗамен[0].ЭтоБулево, "TRUE", "'\\001'::BYTEA");				
				Прервать;
				
			КонецЕсли;
		
		КонецЕсли;
				
	КонецЦикла;
	
	// Если по всем прошли и ничего нет, то это TRUE
	Если ПодстрокаЗамены = Неопределено Тогда
		ПодстрокаЗамены = "TRUE";
	//	НастройкаТестовСервер.УстановитьТекстОшибки(СтрокаТаблицы, СтрШаблон("Поймали ситуацию, когда В модуле НастройкаТестов_СозданиеЗапросов.ИсправитьОтдельныеБинари1ВОбычномЗапросе не смогли преобразовать 0x01 по полю в другом запросе ""%1"". Нужна отладка", ПолеИсточникаБис.МассивПолей[Инд]));
	//	НастройкаТестов_СозданиеЗапросов.УстановитьОшибкуПреобразования(ОшибкиПреобразования, СтрокаТаблицы, ?(СтрокаТаблицы.ВидСобытия = Перечисления.ВидыСобытийЗапросов.ЗаполнениеВременнойТаблицы, "ОтладкаСозданияВТ", "ОтладкаСозданияЗапросов"));
	КонецЕсли;	
	
	Возврат ПодстрокаЗамены;
	
КонецФункции

Функция Исправить0x01ВCaseВОтдельномЗапросе(ЗапросИсточник, СтрокаТаблицы, Знач Результат, ОшибкиПреобразования)

	Для каждого ПолеИсточник Из ЗапросИсточник Цикл
		
		ТекЗапрос = ПланЗапросов.ТекстТекущегоЗапроса(Результат, ЗапросИсточник, ПолеИсточник); 
		
		// Если в текущем запросе есть 0x01ВCase
		Если СтрНайтиПоРегулярномуВыражению(ТекЗапрос, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина > 0 Тогда
			
			Инд = 0;
			Для каждого ПодстрокаПоиска Из ПолеИсточник.МассивПолей Цикл
				
				Если СтрНайтиПоРегулярномуВыражению(ПодстрокаПоиска, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина > 0 Тогда
					
					// Определяем подстроку замены 0x01 по данным полей в текущей позиции в смежных запросам
					ПодстрокаЗамены = ПодстрокаЗамены0x01(СтрокаТаблицы, ЗапросИсточник, Инд, ПодстрокаПоиска, ОшибкиПреобразования);
					// Определяем полную построку замены. Понятно, что теоренически это не правильно, могут быть несколько 0x01, но это в теории)
					ПодстрокаЗамены = СтрЗаменитьПоРегулярномуВыражению(ПодстрокаПоиска, НастройкаТестовКлиентСервер.Шаблон0x01вCase(), СтрШаблон("$1%1", ПодстрокаЗамены));
					
					ПолеИсточник.МассивПолей[Инд] = ПодстрокаЗамены;
					
					// Можем заменить сразу во всем запросе, т.к. явно, что такие конструкции case...end будут уникальны. Правда я не заменяю в плане запроса по остальным, но это и не важно на текущий момент
					Результат = СтрЗаменить(Результат, ПодстрокаПоиска, ПодстрокаЗамены); 
					Если СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина = 0 Тогда
						Прервать;	
					КонецЕсли;
					
				КонецЕсли;
				
				Инд = Инд + 1;
				
			КонецЦикла;
			
			Если СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина = 0 Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПолеИсточник.ОсновнаяТаблица.Запрос <> Неопределено Тогда
			
 			Результат = Исправить0x01ВCaseВОтдельномЗапросе(ПолеИсточник.ОсновнаяТаблица.Запрос.ЗапросИсточник, СтрокаТаблицы, Результат, ОшибкиПреобразования);			
			
			Если СтрНайтиПоРегулярномуВыражению(Результат, НастройкаТестовКлиентСервер.Шаблон0x01вCase()).Длина = 0 Тогда
				Прервать;	
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
			
	Возврат Результат;   
	
КонецФункции

Процедура ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы, НомераСессий = Неопределено)
	
	Если ЗначениеЗаполнено(НомераСессий) Тогда
		Отборы = "НомерСессии В (&НомераСессий)";
		Параметры = Новый Структура("НомераСессий", НомераСессий);
	Иначе
		Отборы = ""; 
		Параметры = Неопределено; 
	КонецЕсли;
	ДопТаблицы.Вставить("ВременныеТаблицыPostgres", НастройкаТестов_СозданиеВременныхТаблиц.ВременныеТаблицыPostgres(НастройкаТеста, , Отборы, Параметры));
	ДопТаблицы.ВременныеТаблицыPostgres.Индексы.Добавить("НомерСессии,ИмяТаблицы");
		
КонецПроцедуры

Процедура ВыполнитьОдинПоток(НастройкаТеста, ТаблицаРезультатов = Неопределено, ДопТаблицы) Экспорт	
	
	Если ТаблицаРезультатов = Неопределено Тогда
		ТаблицаРезультатов = НастройкаТестовСервер.ТаблицаРезультатов(НастройкаТеста, ДопТаблицы);
	КонецЕсли;
	НастройкаТестов_СозданиеЗапросов.ПодготовитьТаблицуРезультатов(ТаблицаРезультатов);
	ДопТаблицы.Вставить("ТаблицаРезультатов", ТаблицаРезультатов);

	Если ДопТаблицы.Многопоточность Тогда
		ДополнитьДопТаблицы(НастройкаТеста, ДопТаблицы, ДопТаблицы.Отборы.ОтборПоСессиям);
	КонецЕсли;
	
	// Основной цикл по строкам ТаблицаРезультатов
	НастройкаТестов_СозданиеЗапросов.ОбработатьСтрокиТаблицыРезультатов(НастройкаТеста, ТаблицаРезультатов, ДопТаблицы, ДопТаблицы.ЗаголовокСообщения, ДопТаблицы.ТекстСообещения);

	НачатьТранзакцию();
	// Сохранение изменненных таблиц в соответсвующие регистры
	НастройкаТестовСервер.ЗагрузитьДанныеВРегистр(НастройкаТеста, ТаблицаРезультатов);
	ЗафиксироватьТранзакцию();
	ТаблицаРезультатов = Неопределено; 
	
КонецПроцедуры

Функция ТаблицаРезультатовПоВыделеннымСтрокам(ВыделенныеСтроки)
	
	// Подготовим ТаблицаРезультатов и заполним ее из переданных выделенных строк
	ТаблицаРезультатов = РегистрыСведений.РезультатыВыполненияЗапросов.СоздатьНаборЗаписей().ВыгрузитьКолонки();
	Для каждого Строка Из ВыделенныеСтроки Цикл
		
		МенеджерЗаписи = РегистрыСведений.РезультатыВыполненияЗапросов.СоздатьМенеджерЗаписи();
		ЗаполнитьЗначенияСвойств(МенеджерЗаписи, Строка);
		МенеджерЗаписи.Прочитать();
		
		НоваяСтрока = ТаблицаРезультатов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, МенеджерЗаписи);
		
	КонецЦикла;
	
	Возврат ТаблицаРезультатов;
	
КонецФункции

Функция ТаблицаРезультатовПоОтбору(Настройки)
	
	СхемаКомпоновкиДанных = Справочники.НастройкаТеста.ПолучитьМакет("Макет");
	
	// Добавляем группировку.
	Настройки.Структура.Очистить();
	ДетальныеЗаписи = Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));           
	
	Поля = Новый Массив;
	Поля.Добавить("НастройкаТеста");
	Поля.Добавить("ДатаСобытия"); 
	Поля.Добавить("НомерСессии");
	Поля.Добавить("НомерСобытия"); 
	Поля.Добавить("ВидСобытия"); 
	Поля.Добавить("ТекстЗапросаMSSQL"); 
	Поля.Добавить("КоличествоСтрокMSSQL"); 
	Поля.Добавить("ДлительностьВыполненияMSSQL"); 
	Поля.Добавить("ТекстЗапросаPostgres"); 
	Поля.Добавить("КоличествоСтрокPostgres"); 
	Поля.Добавить("ДлительностьВыполненияPostgres"); 
	Поля.Добавить("ВидОшибки"); 
	Поля.Добавить("ОшибкаПреобразования"); 
	Поля.Добавить("ТекстОшибки"); 
	Поля.Добавить("ОшибкаПриВыполнения"); 
	
	Для каждого Поле Из Поля Цикл
		
		ВыбранноеПоле = ДетальныеЗаписи.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Заголовок     = Поле;
		ВыбранноеПоле.Использование = Истина;
		ВыбранноеПоле.Поле          = Новый ПолеКомпоновкиДанных(Поле);
		
	КонецЦикла;
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных; 
	КомпоновщикНастроек.ЗагрузитьНастройки(Настройки);
	
	// Выполняем схему компоновки.
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	Макет = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, КомпоновщикНастроек.ПолучитьНастройки(),,,
	
	Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(Макет);

	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ТаблицаДанных = ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	Возврат ТаблицаДанных;
	
КонецФункции

#КонецОбласти